<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Live Demo | x402 Labs - Micropayments for the Machine Economy</title>
  <link rel="icon" type="image/png" href="/assets/xlabs-new.png">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  
  <!-- Enhanced Buffer polyfill for Solana web3.js -->
  <script>
    (function() {
      // Complete Buffer polyfill that @solana/web3.js needs
      class BufferPolyfill extends Uint8Array {
        constructor(arg, encodingOrOffset, length) {
          if (typeof arg === 'number') {
            super(arg);
          } else if (typeof arg === 'string') {
            const encoded = new TextEncoder().encode(arg);
            super(encoded);
          } else {
            super(arg, encodingOrOffset, length);
          }
        }
        
        static from(value, encoding) {
          if (typeof value === 'string') {
            return new TextEncoder().encode(value);
          }
          if (value instanceof Uint8Array) {
            return value;
          }
          if (Array.isArray(value)) {
            return new Uint8Array(value);
          }
          if (value?.buffer) {
            return new Uint8Array(value.buffer);
          }
          return new Uint8Array(value);
        }
        
        static alloc(size, fill = 0) {
          const buf = new Uint8Array(size);
          if (fill !== 0) buf.fill(fill);
          return buf;
        }
        
        static allocUnsafe(size) {
          return new Uint8Array(size);
        }
        
        static isBuffer(obj) {
          return obj instanceof Uint8Array;
        }
        
        static concat(list, totalLength) {
          if (!totalLength) {
            totalLength = list.reduce((acc, buf) => acc + buf.length, 0);
          }
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const buf of list) {
            result.set(buf, offset);
            offset += buf.length;
          }
          return result;
        }
      }
      
      window.Buffer = BufferPolyfill;
      console.log('‚úÖ Enhanced Buffer polyfill loaded');
      console.log('‚úÖ Buffer.from:', typeof Buffer.from === 'function');
      console.log('‚úÖ Buffer.alloc:', typeof Buffer.alloc === 'function');
    })();
  </script>

  <!-- Use v1.20.3 - Ancient stable version, proven to work with Phantom -->
  <script src="https://unpkg.com/@solana/web3.js@1.20.3/lib/index.iife.min.js"></script>
  
  <!-- SPL Token functions (manual implementation since CDN doesn't have browser build) -->
  <script>
    // Manual implementation of SPL Token functions we need
    window.splToken = {
      TOKEN_PROGRAM_ID: new window.solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
      ASSOCIATED_TOKEN_PROGRAM_ID: new window.solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'),
      SYSTEM_PROGRAM_ID: new window.solanaWeb3.PublicKey('11111111111111111111111111111111'),
      SYSVAR_RENT_PUBKEY: new window.solanaWeb3.PublicKey('SysvarRent111111111111111111111111111111111'),
      COMPUTE_BUDGET_PROGRAM_ID: new window.solanaWeb3.PublicKey('ComputeBudget111111111111111111111111111111'),
      
      // Find associated token address for an SPL token
      async getAssociatedTokenAddress(mint, owner) {
        const [address] = await window.solanaWeb3.PublicKey.findProgramAddress(
          [
            owner.toBuffer(),
            this.TOKEN_PROGRAM_ID.toBuffer(),
            mint.toBuffer(),
          ],
          this.ASSOCIATED_TOKEN_PROGRAM_ID
        );
        
        return address;
      },
      
      // Create associated token account instruction
      createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint) {
        const keys = [
          { pubkey: payer, isSigner: true, isWritable: true },
          { pubkey: associatedToken, isSigner: false, isWritable: true },
          { pubkey: owner, isSigner: false, isWritable: false },
          { pubkey: mint, isSigner: false, isWritable: false },
          { pubkey: this.SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: this.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: this.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        ];
        
        return new window.solanaWeb3.TransactionInstruction({
          keys,
          programId: this.ASSOCIATED_TOKEN_PROGRAM_ID,
          data: new Uint8Array([0]), // CreateATA discriminator
        });
      },
      
      // Create SPL token transfer instruction
      createTransferInstruction(source, destination, owner, amount) {
        const keys = [
          { pubkey: source, isSigner: false, isWritable: true },
          { pubkey: destination, isSigner: false, isWritable: true },
          { pubkey: owner, isSigner: true, isWritable: false },
        ];
        
        // SPL Token Transfer instruction data
        // Instruction discriminator: 3 (Transfer)
        // Amount: u64 (8 bytes, little-endian)
        const dataLayout = new Uint8Array(9);
        dataLayout[0] = 3; // Transfer instruction
        
        // Write amount as little-endian u64
        const amountBigInt = BigInt(amount);
        for (let i = 0; i < 8; i++) {
          dataLayout[1 + i] = Number((amountBigInt >> BigInt(8 * i)) & BigInt(0xff));
        }
        
        return new window.solanaWeb3.TransactionInstruction({
          keys,
          programId: this.TOKEN_PROGRAM_ID,
          data: dataLayout,
        });
      },
      
      // Create SPL token TransferChecked instruction (required by PayAI)
      createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals) {
        const keys = [
          { pubkey: source, isSigner: false, isWritable: true },
          { pubkey: mint, isSigner: false, isWritable: false },
          { pubkey: destination, isSigner: false, isWritable: true },
          { pubkey: owner, isSigner: true, isWritable: false },
        ];
        
        // SPL Token TransferChecked instruction data
        // Instruction discriminator: 12 (TransferChecked)
        // Amount: u64, Decimals: u8
        const dataLayout = new Uint8Array(10);
        dataLayout[0] = 12; // TransferChecked instruction
        
        // Write amount as little-endian u64
        const amountBigInt = BigInt(amount);
        for (let i = 0; i < 8; i++) {
          dataLayout[1 + i] = Number((amountBigInt >> BigInt(8 * i)) & BigInt(0xff));
        }
        
        // Write decimals as u8
        dataLayout[9] = decimals;
        
        return new window.solanaWeb3.TransactionInstruction({
          keys,
          programId: this.TOKEN_PROGRAM_ID,
          data: dataLayout,
        });
      },
      
      // ComputeBudget: Set compute unit limit
      createComputeUnitLimitInstruction(units) {
        const dataLayout = new Uint8Array(9);
        dataLayout[0] = 2; // SetComputeUnitLimit discriminator
        
        // Write units as little-endian u32
        for (let i = 0; i < 4; i++) {
          dataLayout[1 + i] = (units >> (8 * i)) & 0xff;
        }
        
        return new window.solanaWeb3.TransactionInstruction({
          keys: [],
          programId: this.COMPUTE_BUDGET_PROGRAM_ID,
          data: dataLayout,
        });
      },
      
      // ComputeBudget: Set compute unit price
      createComputeUnitPriceInstruction(microLamports) {
        const dataLayout = new Uint8Array(9);
        dataLayout[0] = 3; // SetComputeUnitPrice discriminator
        
        // Write microLamports as little-endian u64
        const microLamportsBigInt = BigInt(microLamports);
        for (let i = 0; i < 8; i++) {
          dataLayout[1 + i] = Number((microLamportsBigInt >> BigInt(8 * i)) & BigInt(0xff));
        }
        
        return new window.solanaWeb3.TransactionInstruction({
          keys: [],
          programId: this.COMPUTE_BUDGET_PROGRAM_ID,
          data: dataLayout,
        });
      }
    };
    
    console.log('‚úÖ SPL Token functions loaded (manual implementation)');
  </script>
  
  <!-- Inline bs58 implementation (guaranteed to work) -->
  <script>
    // Minimal bs58 encode/decode for browser (no dependencies)
    const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    window.bs58 = {
      encode: function(buffer) {
        if (buffer.length === 0) return '';
        const digits = [0];
        for (let i = 0; i < buffer.length; i++) {
          let carry = buffer[i];
          for (let j = 0; j < digits.length; j++) {
            carry += digits[j] << 8;
            digits[j] = carry % 58;
            carry = (carry / 58) | 0;
          }
          while (carry > 0) {
            digits.push(carry % 58);
            carry = (carry / 58) | 0;
          }
        }
        let result = '';
        for (let i = 0; i < buffer.length && buffer[i] === 0; i++) result += '1';
        for (let i = digits.length - 1; i >= 0; i--) result += BASE58_ALPHABET[digits[i]];
        return result;
      },
      decode: function(string) {
        if (string.length === 0) return new Uint8Array(0);
        const bytes = [0];
        for (let i = 0; i < string.length; i++) {
          const value = BASE58_ALPHABET.indexOf(string[i]);
          if (value === -1) throw new Error('Invalid base58 character');
          let carry = value;
          for (let j = 0; j < bytes.length; j++) {
            carry += bytes[j] * 58;
            bytes[j] = carry & 0xff;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 0xff);
            carry >>= 8;
          }
        }
        for (let i = 0; i < string.length && string[i] === '1'; i++) bytes.push(0);
        return new Uint8Array(bytes.reverse());
      }
    };
    console.log('‚úÖ Solana web3.js loaded:', typeof window.solanaWeb3 !== 'undefined');
    console.log('‚úÖ bs58 loaded:', typeof window.bs58 !== 'undefined');
  </script>
  <!-- Add runtime SPL loader with check -->
  <script>
    // PayAI SDK is integrated on the backend - no SPL Token library needed on frontend!
    // The backend handles all PayAI payment processing via the official x402-solana SDK
    
    console.log('‚úÖ PayAI option enabled (backend SDK integration)');
    console.log('   PayAI Treasury: 26AvBMEXaJAfA2R7wtQiPNYeWUd8QSi6rvy5i5W78vNR');
    console.log('   Facilitator URL: https://facilitator.payai.network');
    
    // Enable PayAI option immediately - backend handles everything
    document.addEventListener('DOMContentLoaded', () => {
      const payaiOption = document.querySelector('#facilitator option[value="payai"]');
      if (payaiOption) {
        payaiOption.disabled = false;
        payaiOption.text = 'PayAI Network (USDC on Solana)';
        console.log('‚úÖ PayAI Network option ready');
      }
    });
  </script>
  
  <!-- x402 Labs theme (design.svg palette) -->
  <style>
    :root {
      --bg: #DFEFFB;
      --bg2: #E8F4F8;
      --text: #0E4D81;
      --primary: #177CCF;
      --primaryDark: #0E4D81;
      --card: #FFFFFF;
      --soft: #E7F1F9;
      --muted: #6B8CA8;
    }
    body { background: linear-gradient(135deg, var(--bg) 0%, var(--bg2) 100%) !important; color: var(--text) !important; }
    /* Map dark utility classes to light theme locally */
    .bg-gray-900 { background-color: var(--bg) !important; }
    .bg-gray-800 { background-color: var(--card) !important; border: 1px solid rgba(23,124,207,0.15); box-shadow: 0 6px 20px rgba(14,77,129,0.06); }
    .bg-gray-700 { background-color: var(--soft) !important; color: var(--text) !important; }
    .text-white { color: var(--text) !important; }
    .text-gray-400 { color: var(--muted) !important; }
    .text-blue-300 { color: var(--primary) !important; }
    .text-purple-400 { color: var(--primary) !important; }
    .bg-blue-600, .bg-purple-600, .bg-green-600 { background: linear-gradient(135deg, var(--primary) 0%, var(--primaryDark) 100%) !important; }
    .hover\:bg-blue-700:hover, .hover\:bg-purple-700:hover, .hover\:bg-green-700:hover { filter: brightness(0.95); }
    pre.bg-gray-900 { background-color: var(--soft) !important; color: var(--text) !important; }
    /* Inputs */
    input#wallet, input#params, select#method, select#facilitator { border: 1px solid rgba(23,124,207,0.15); }
    /* Back link */
    a[href="/"] { color: var(--primary) !important; }
    /* Status panels */
    .bg-orange-900 { background-color: rgba(23,124,207,0.08) !important; }
    .border-orange-500 { border-color: rgba(23,124,207,0.35) !important; }
    .log-pane {
      background-color: var(--soft) !important;
      color: var(--text) !important;
      border-radius: 0.75rem;
      padding: 0.75rem;
      font-size: 0.75rem;
      max-height: 14rem;
      overflow: auto;
      transition: max-height 0.25s ease;
    }
    .log-pane.expanded {
      max-height: 32rem;
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .panel-actions {
      display: flex;
      gap: 0.5rem;
    }
    .panel-button {
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(23,124,207,0.25);
      background: rgba(23,124,207,0.08);
      color: var(--primaryDark);
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .panel-button:hover {
      background: rgba(23,124,207,0.15);
      transform: translateY(-1px);
    }
    .panel-button.is-active {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primaryDark) 100%);
      color: #fff;
      border-color: transparent;
    }
  </style>
  
  <!-- Header Navigation (consistent across all pages) -->
  <style>
    .main-header {
      background: rgba(30, 41, 59, 0.5);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      border-bottom: 1px solid rgba(139, 92, 246, 0.1);
    }
    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .main-nav {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }
    .main-nav a {
      color: #cbd5e1;
      text-decoration: none;
      font-weight: 500;
      font-size: 0.9rem;
    }
    .main-nav a:hover {
      color: #a78bfa;
    }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">

  <!-- Header -->
  <header class="main-header">
    <div class="header-content">
      <a href="/" style="display: flex; align-items: center;">
        <img src="/assets/xlabs-new.png" alt="x402 Labs" style="height: 64px; width: auto;">
      </a>
      <nav class="main-nav">
        <a href="/">Home</a>
        <a href="/api-docs">API Docs</a>
        <a href="/api-reference">API Reference</a>
        <a href="/providers-ui">Providers</a>
        <a href="/demo">Demo</a>
        <a href="https://x.com/x402labs" target="_blank" rel="noopener noreferrer" style="display: inline-flex; align-items: center;">
          <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a href="https://github.com/x402-labs" target="_blank" rel="noopener noreferrer">
          <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
            <path d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z"/>
          </svg>
        </a>
      </nav>
    </div>
  </header>

  <div class="container mx-auto px-6 py-12">
    <div class="flex items-center justify-between mb-8">
      <h1 class="text-4xl font-bold">Live Demo: Pay with x402</h1>
    </div>
    <p class="text-gray-400 mb-8">Micropayments for the Machine Economy‚Ñ¢</p>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- LEFT: Controls -->
      <div class="space-y-6">
        <div class="bg-gray-800 p-6 rounded-xl">
          <h2 class="text-xl font-semibold mb-4">1. Connect Wallet</h2>
          <button id="connect" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold">
            Connect Phantom
          </button>
          <p id="wallet" class="mt-2 text-sm text-gray-400"></p>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl">
          <h2 class="text-xl font-semibold mb-4">2. Make RPC Call</h2>
          <label class="block text-sm font-medium text-gray-300 mb-2">Network</label>
          <select id="chain" class="w-full p-2 bg-gray-700 rounded mb-2">
            <option value="solana">Solana</option>
            <option value="base">Base</option>
          </select>
          <p class="text-xs text-gray-400 mb-3 italic">Choose the chain. Solana supports CodeNut, PayAI, or x402labs. Base currently routes through CodeNut.</p>
          <label class="block text-sm font-medium text-gray-300 mb-2">Payment Facilitator</label>
          <select id="facilitator" class="w-full p-2 bg-gray-700 rounded mb-1">
            <option value="codenut"> CodeNut Pay - USDC (Solana/Base) - Zero-config, multi-chain</option>
            <option value="payai">üåê PayAI Network - USDC (Solana) - Fast settlement, no fees</option>
            <option value="x402labs" selected> x402labs - SOL (Solana) - Self-hosted, full control</option>
          </select>
          <p id="facilitator-help" class="text-xs text-gray-400 mb-3 italic">Choose how you want to pay: USDC (CodeNut/PayAI) or SOL (x402labs)</p>
          <select id="method" class="w-full p-2 bg-gray-700 rounded mb-3">
            <option value="getSlot">getSlot (Solana) - no params needed</option>
            <option value="getBalance">getBalance (Solana) - needs address</option>
            <option value="getAccountInfo">getAccountInfo (Solana) - get account data</option>
            <option value="getTransaction">getTransaction (Solana) - get tx by signature</option>
            <option value="getTokenAccountsByOwner">getTokenAccountsByOwner (Solana) - SPL tokens</option>
            <option value="getSignaturesForAddress">getSignaturesForAddress (Solana) - tx history</option>
            <option value="sendTransaction">sendTransaction (Solana) - broadcast tx</option>
            <option value="eth_blockNumber">eth_blockNumber (Base)</option>
          </select>
          <input id="params" placeholder='Empty for getSlot, or paste address for getBalance' class="w-full p-2 bg-gray-700 rounded mb-3 text-sm" />
          <button id="buildTx" class="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm mb-2" style="display:none;">
            üì¶ Build Sample Transaction
          </button>
          <button id="call" class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-semibold">
            Call RPC
          </button>
        </div>

        <div id="status" class="bg-gray-800 p-4 rounded-xl text-sm"></div>
      </div>

      <!-- RIGHT: Response -->
      <div class="space-y-6">
        <div class="bg-gray-800 p-6 rounded-xl">
          <div class="panel-header">
            <h2 class="text-xl font-semibold">Request</h2>
            <div class="panel-actions">
              <button class="panel-button" data-copy="request">Copy</button>
              <button class="panel-button" data-toggle="request">Expand</button>
            </div>
          </div>
          <pre id="request" class="log-pane text-green-400"></pre>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl">
          <div class="panel-header">
            <h2 class="text-xl font-semibold">Response</h2>
            <div class="panel-actions">
              <button class="panel-button" data-copy="response">Copy</button>
              <button class="panel-button" data-toggle="response">Expand</button>
            </div>
          </div>
          <pre id="response" class="log-pane text-blue-300"></pre>
        </div>
      </div>
    </div>
  </div>

  <script>
    const BASE_URL = window.location.hostname === 'localhost' 
      ? 'http://localhost:3000'
      : window.location.origin;
    
    const API = `${BASE_URL}/rpc`;
    const SOLANA_RPC_PROXY = `${BASE_URL}/solana-rpc`;
    
    console.log('Using API:', API);
    console.log('Using Solana RPC Proxy:', SOLANA_RPC_PROXY);
    
    let wallet = null;
    let currentInvoice = null;
    let sampleTxBase58 = null;
    const chainSelect = document.getElementById('chain');
    const methodSelect = document.getElementById('method');
    const facilitatorSelect = document.getElementById('facilitator');
    const facilitatorHelp = document.getElementById('facilitator-help');
    const paramsInputElement = document.getElementById('params');
    const walletInfo = document.getElementById('wallet');
    const statusPanel = document.getElementById('status');
    
    const CHAIN_METHODS = {
      solana: [
        { value: 'getSlot', label: 'getSlot (Solana) - no params needed' },
        { value: 'getBalance', label: 'getBalance (Solana) - needs address' },
        { value: 'getAccountInfo', label: 'getAccountInfo (Solana) - get account data' },
        { value: 'getTransaction', label: 'getTransaction (Solana) - get tx by signature' },
        { value: 'getTokenAccountsByOwner', label: 'getTokenAccountsByOwner (Solana) - SPL tokens' },
        { value: 'getSignaturesForAddress', label: 'getSignaturesForAddress (Solana) - tx history' },
        { value: 'sendTransaction', label: 'sendTransaction (Solana) - broadcast tx' },
      ],
      base: [
        { value: 'eth_blockNumber', label: 'eth_blockNumber (Base) - no params needed' },
      ],
    };
    
    const METHOD_PLACEHOLDERS = {
      getSlot: 'No params needed - leave empty',
      getBalance: 'Paste a Solana address (e.g., EPjFWdd5AufqSSqeM2...)',
      getAccountInfo: 'Paste a Solana address to inspect',
      getTransaction: 'Paste a transaction signature (base58)',
      getTokenAccountsByOwner: '["<wallet-address>", {"programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"}]',
      getSignaturesForAddress: 'Paste a wallet address for tx history',
      sendTransaction: 'Click "Build Sample Transaction" first, or paste base58 tx',
      eth_blockNumber: 'No params needed - leave empty',
    };
    
    const FACILITATORS_BY_CHAIN = {
      solana: ['codenut', 'payai', 'x402labs'],
      base: ['codenut'],
    };
    
    const FACILITATOR_NOTES = {
      solana: 'Use SOL with x402labs or USDC via CodeNut / PayAI on Solana.',
      base: 'Base payments settle via CodeNut Pay (USDC) and prompt an EVM wallet such as MetaMask.',
    };
    
    walletInfo.innerHTML = `<span class="text-xs text-gray-400">Connect Phantom to explore Solana payments. No Phantom? Install it or switch the network selector to Base to try the CodeNut + MetaMask flow.</span>`;
    statusPanel.innerHTML = `<div class="bg-gray-700 rounded-lg p-3 text-xs text-gray-500">Ready when you are. Select a network and method, then hit ‚ÄúCall RPC‚Äù to fetch data. You will get a 402 challenge before the payment step.</div>`;
    
    function renderMethods(chain) {
      const options = CHAIN_METHODS[chain] || [];
      methodSelect.innerHTML = '';
      options.forEach(opt => {
        const optionEl = document.createElement('option');
        optionEl.value = opt.value;
        optionEl.textContent = opt.label;
        methodSelect.appendChild(optionEl);
      });
      methodSelect.dispatchEvent(new Event('change'));
    }
    
    function updateFacilitatorOptions(chain) {
      const allowed = new Set(FACILITATORS_BY_CHAIN[chain] || []);
      Array.from(facilitatorSelect.options).forEach(option => {
        const isAllowed = allowed.has(option.value);
        option.disabled = !isAllowed;
        option.hidden = !isAllowed;
      });
      if (facilitatorSelect.options[facilitatorSelect.selectedIndex]?.disabled ||
          facilitatorSelect.options[facilitatorSelect.selectedIndex]?.hidden) {
        const firstAllowed = Array.from(facilitatorSelect.options).find(opt => !opt.disabled && !opt.hidden);
        if (firstAllowed) {
          facilitatorSelect.value = firstAllowed.value;
        }
      }
      facilitatorHelp.textContent = FACILITATOR_NOTES[chain] || 'Select a facilitator compatible with this network.';
    }
    
    function updateParamsPlaceholder() {
      const method = methodSelect.value;
      paramsInputElement.placeholder = METHOD_PLACEHOLDERS[method] || 'Enter params as JSON array';
    }
    
    function attachPanelControls(id) {
      const copyBtn = document.querySelector(`[data-copy="${id}"]`);
      const toggleBtn = document.querySelector(`[data-toggle="${id}"]`);
      const pane = document.getElementById(id);
      if (copyBtn && pane) {
        const original = copyBtn.textContent;
        copyBtn.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(pane.textContent || '');
            copyBtn.classList.add('is-active');
            copyBtn.textContent = 'Copied!';
            setTimeout(() => {
              copyBtn.classList.remove('is-active');
              copyBtn.textContent = original;
            }, 1200);
          } catch (err) {
            console.error('Clipboard copy failed', err);
          }
        });
      }
      if (toggleBtn && pane) {
        toggleBtn.addEventListener('click', () => {
          const expanded = pane.classList.toggle('expanded');
          toggleBtn.textContent = expanded ? 'Collapse' : 'Expand';
          toggleBtn.classList.toggle('is-active', expanded);
        });
      }
    }
    
    ['request', 'response'].forEach(attachPanelControls);
    renderMethods(chainSelect.value);
    updateFacilitatorOptions(chainSelect.value);
    updateParamsPlaceholder();
    
    chainSelect.addEventListener('change', () => {
      currentInvoice = null;
      renderMethods(chainSelect.value);
      updateFacilitatorOptions(chainSelect.value);
      updateParamsPlaceholder();
      paramsInputElement.value = '';
      statusPanel.innerHTML = `<div class="bg-gray-700 rounded-lg p-3 text-xs text-gray-500">Network switched to ${chainSelect.value.toUpperCase()}. Pick a method, facilitator, then call RPC.</div>`;
    });
    
    methodSelect.addEventListener('change', (e) => {
      const buildBtn = document.getElementById('buildTx');
      const method = e.target.value;
      
      if (method === 'sendTransaction') {
        buildBtn.style.display = 'block';
        buildBtn.innerHTML = 'üì¶ Build Sample Transaction';
        buildBtn.classList.remove('bg-green-600');
        if (!buildBtn.classList.contains('bg-blue-600')) {
          buildBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
        }
        paramsInputElement.placeholder = METHOD_PLACEHOLDERS[method];
      } else {
        buildBtn.style.display = 'none';
      }
      updateParamsPlaceholder();
    });

    document.getElementById('connect').onclick = async () => {
      if (!window.solana?.isPhantom) {
        walletInfo.innerHTML = `
          <div class="bg-gray-700 rounded-lg p-3 text-sm">
            <p class="text-red-500 font-semibold mb-2">Phantom wallet not detected.</p>
            <p class="text-gray-500 mb-3">Install the <a href="https://phantom.app/" class="underline text-blue-500" target="_blank" rel="noopener noreferrer">Phantom browser extension</a> to try Solana flows. You can also switch the network selector to <strong>Base</strong> and continue with CodeNut + MetaMask.</p>
            <button id="phantomDismiss" class="panel-button">Dismiss</button>
          </div>
        `;
        const dismissBtn = document.getElementById('phantomDismiss');
        if (dismissBtn) {
          dismissBtn.onclick = () => {
            walletInfo.innerHTML = `<span class="text-xs text-gray-400">You can continue without Phantom. For SOL payments install Phantom; for Base select CodeNut and approve the MetaMask prompt when paying.</span>`;
          };
        }
        return;
      }
      
      try {
        await window.solana.connect();
        wallet = window.solana;
        
        const balanceCheck = await checkBalance(wallet);
        
        walletInfo.innerHTML = `
          <span class="text-green-400">‚úÖ Connected</span><br>
          <span class="text-xs">${wallet.publicKey.toBase58().slice(0,8)}...</span><br>
          <span class="text-sm ${balanceCheck.solSufficient ? 'text-green-400' : 'text-orange-400'}">SOL: ${balanceCheck.solCurrent}</span><br>
          <span class="text-sm ${balanceCheck.usdcSufficient ? 'text-green-400' : 'text-orange-400'}">USDC: ${balanceCheck.usdcCurrent}</span>
          ${!balanceCheck.solSufficient ? '<br><span class="text-orange-400 text-xs">‚ö†Ô∏è Low SOL (for x402labs)</span>' : ''}
          ${!balanceCheck.usdcSufficient ? '<br><span class="text-orange-400 text-xs">‚ö†Ô∏è Low USDC (for PayAI)</span>' : ''}
        `;
        
        if (chainSelect.value === 'solana') {
        if (balanceCheck.solSufficient && !balanceCheck.usdcSufficient) {
          facilitatorSelect.value = 'x402labs';
          console.log('üí° Auto-selected x402labs (you have SOL but no USDC)');
        } else if (balanceCheck.usdcSufficient && !balanceCheck.solSufficient) {
            facilitatorSelect.value = 'codenut';
            console.log('üí° Auto-selected CodeNut (you have USDC but no SOL)');
        }
        }
        updateFacilitatorOptions(chainSelect.value);
      } catch (err) {
        walletInfo.innerHTML = `<span class="text-red-400">‚ùå ${err.message}</span>`;
      }
    };

    // Build sample transaction for sendTransaction
    document.getElementById('buildTx').onclick = async () => {
      if (!wallet) return alert('Connect wallet first');
      
      try {
        document.getElementById('buildTx').innerHTML = '‚è≥ Building...';
        
        const { Transaction, SystemProgram, PublicKey } = window.solanaWeb3;
        
        // Get recent blockhash
        const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            jsonrpc: '2.0',
            id: 1,
            method: 'getLatestBlockhash',
            params: [{ commitment: 'finalized' }]
          })
        });
        const blockhashData = await blockhashRes.json();
        const blockhash = blockhashData.result.value.blockhash;
        
        // Build a memo transaction (safe, cheap, demonstrative)
        const tx = new Transaction();
        tx.recentBlockhash = blockhash;
        tx.feePayer = wallet.publicKey;
        
        // Add memo instruction
        const memoText = `x402 Demo - ${new Date().toISOString()}`;
        const memoData = new TextEncoder().encode(memoText);
        const MEMO_PROGRAM_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
        
        const { TransactionInstruction } = window.solanaWeb3;
        tx.add(new TransactionInstruction({
          keys: [{ pubkey: wallet.publicKey, isSigner: true, isWritable: false }],
          programId: MEMO_PROGRAM_ID,
          data: memoData
        }));
        
        // Sign transaction
        const signed = await wallet.signTransaction(tx);
        const serialized = signed.serialize();
        sampleTxBase58 = bs58.encode(serialized);
        
        // Auto-fill params field
        document.getElementById('params').value = sampleTxBase58;
        document.getElementById('buildTx').innerHTML = '‚úÖ Transaction Built!';
        document.getElementById('buildTx').classList.remove('bg-blue-600', 'hover:bg-blue-700');
        document.getElementById('buildTx').classList.add('bg-green-600');
        
        console.log('‚úÖ Built sample transaction:', sampleTxBase58.substring(0, 20) + '...');
      } catch (err) {
        console.error('‚ùå Build failed:', err);
        document.getElementById('buildTx').innerHTML = '‚ùå Build Failed - Retry';
        document.getElementById('buildTx').classList.remove('bg-blue-600');
        document.getElementById('buildTx').classList.add('bg-red-600');
      }
    };

    // Add facilitator change listener to warn about balance
    facilitatorSelect.addEventListener('change', async (e) => {
      if (!wallet) return;
      const facilitator = e.target.value;
      const chain = chainSelect.value;
      if (chain !== 'solana') return;
      
      const balanceCheck = await checkBalance(wallet);
      
      if ((facilitator === 'payai' || facilitator === 'codenut') && !balanceCheck.usdcSufficient) {
        alert(`‚ö†Ô∏è Warning: You selected ${facilitator === 'codenut' ? 'CodeNut' : 'PayAI'} (USDC) but have insufficient USDC.\n\nRecommendation: Use x402labs (SOL) instead or acquire USDC before proceeding.`);
      } else if (facilitator === 'x402labs' && !balanceCheck.solSufficient) {
        alert('‚ö†Ô∏è Warning: You selected x402labs (SOL) but have insufficient SOL.\n\nRecommendation: Use CodeNut or PayAI (USDC) instead if you have USDC.');
      }
    });

    document.getElementById('call').onclick = async () => {
      const method = methodSelect.value;
      const paramsInput = paramsInputElement.value.trim();
      const chain = chainSelect.value;
      const facilitator = facilitatorSelect.value;

      if (!wallet && chain === 'solana') {
        alert('Tip: connect Phantom before paying so you can sign the transaction. You can still preview the invoice without a wallet.');
      }
      
      // Smart params parsing: handle JSON array, raw string, or empty
      let params = [];
      if (paramsInput) {
        try {
          params = JSON.parse(paramsInput); // Try parsing as JSON first
          console.log('‚úÖ Parsed params as JSON:', params);
        } catch (e) {
          console.log('‚úÖ Auto-wrapped address in array:', [paramsInput]);
          params = [paramsInput];
        }
      } else {
        console.log('‚úÖ No params (empty array)');
      }

      const req = { method, params, chain, facilitator };
      document.getElementById('request').textContent = JSON.stringify(req, null, 2);
      statusPanel.innerHTML = `<p class="text-yellow-400">‚è≥ Sending...</p>`;

      try {
      const res = await fetch(API, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req),
      });

      if (res.status === 402) {
        const x402Response = await res.json();
        
        if (!x402Response.accepts || x402Response.accepts.length === 0) {
          throw new Error('Invalid x402 response: no payment options');
        }
        
        const paymentDetails = x402Response.accepts[0];
        currentInvoice = paymentDetails; // Store for payNow()
        
        const baseAmount = parseFloat(paymentDetails.maxAmountRequired);
        const asset = paymentDetails.asset;
        let displayAmount = '';
        let usdValue = '';
        
        if (asset === 'USDC') {
          const usdc = baseAmount / 1e6;
          displayAmount = `${usdc.toFixed(6)} USDC`;
          usdValue = `‚âà $${usdc.toFixed(6)} USD`;
        } else if (asset === 'SOL') {
          const sol = baseAmount / 1e9;
            const usd = sol * 200;
          displayAmount = `${sol.toFixed(9)} SOL`;
          usdValue = `‚âà $${usd.toFixed(6)} USD`;
        } else if (asset === 'ETH') {
          const eth = baseAmount / 1e18;
            const usd = eth * 3000;
          displayAmount = `${eth.toFixed(12)} ETH`;
          usdValue = `‚âà $${usd.toFixed(6)} USD`;
        }
        
        document.getElementById('response').textContent = JSON.stringify(x402Response, null, 2);
          statusPanel.innerHTML = `
          <div class="bg-orange-900 bg-opacity-30 border border-orange-500 rounded-lg p-4">
            <p class="text-orange-300 font-semibold mb-2">üí≥ Payment Required</p>
            <p class="text-orange-200 text-sm mb-2">Amount: <strong>${displayAmount}</strong></p>
            <p class="text-orange-200 text-xs mb-1">${usdValue}</p>
            <p class="text-orange-200 text-sm mb-2">Provider: ${paymentDetails.extra?.provider || 'Best Available'}</p>
              <p class="text-orange-200 text-xs mb-3">Payment: ${facilitator === 'x402labs' ? 'SOL (x402labs)' : facilitator === 'codenut' ? 'USDC (CodeNut)' : 'USDC (PayAI Network)'}</p>
            <button onclick="payNow()" class="mt-3 w-full px-4 py-2 bg-white text-purple-900 font-bold rounded-lg hover:bg-purple-100">
                üí∞ Pay Now
            </button>
          </div>
        `;
      } else {
          const data = await res.json();
          document.getElementById('response').textContent = JSON.stringify(data, null, 2);
          if (data.x402) {
            statusPanel.innerHTML = `
              <div class="bg-green-900 bg-opacity-30 border border-green-500 rounded-lg p-4">
                <p class="text-green-300 font-semibold">‚úÖ Paid!</p>
                <p class="text-green-200 text-sm">Tx: <a href="${data.x402.paymentInfo.explorer}" target="_blank" class="underline">${data.x402.paymentInfo.txHash.slice(0,8)}...</a></p>
              </div>
            `;
          } else {
            statusPanel.innerHTML = `<p class="text-green-400">‚úÖ Response received.</p>`;
          }
        }
      } catch (err) {
        statusPanel.innerHTML = `<p class="text-red-400">‚ùå ${err.message}</p>`;
      }
    };

    async function checkBalance(wallet) {
      try {
        // Import PublicKey from solanaWeb3
        const { PublicKey } = window.solanaWeb3;
        
        // Existing SOL balance
        const solRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ method: 'getBalance', params: [wallet.publicKey.toBase58()] })
        });
        const solData = await solRes.json();
        const solBalance = solData.result?.value || 0;
        const solBalanceSOL = solBalance / 1e9;
        const minSOL = 0.001;

        // USDC balance check (for PayAI)
        // Note: PayAI Network facilitator handles USDC transfers on backend
        // Frontend just shows balance for user information
        console.log('üí∞ Checking USDC balance (PayAI Network)');
        
        const USDC_MINT = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
        
        // Use getTokenAccountsByOwner to find all USDC accounts
        // This is more reliable than calculating ATA manually
        const usdcAccountsRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTokenAccountsByOwner',
            params: [
              wallet.publicKey.toBase58(),
              { mint: USDC_MINT },
              { encoding: 'jsonParsed' }
            ]
          })
        });
        
        const usdcAccountsData = await usdcAccountsRes.json();
        let usdcBalance = 0;
        
        if (usdcAccountsData.result?.value && usdcAccountsData.result.value.length > 0) {
          // Found USDC account(s) - sum up balances
          usdcBalance = usdcAccountsData.result.value.reduce((total, account) => {
            const tokenAmount = account.account.data.parsed.info.tokenAmount.uiAmount;
            return total + (tokenAmount || 0);
          }, 0);
          console.log(`‚úÖ Found ${usdcAccountsData.result.value.length} USDC account(s), total: ${usdcBalance} USDC`);
        } else {
          console.warn('‚ö†Ô∏è No USDC accounts found for this wallet');
        }
        
        const minUSDC = 0.001; // Minimum USDC for payments (reduced from 0.02)

        return {
          solSufficient: solBalanceSOL >= minSOL,
          usdcSufficient: usdcBalance >= minUSDC,
          solCurrent: `${solBalanceSOL.toFixed(4)} SOL`,
          usdcCurrent: `${usdcBalance.toFixed(2)} USDC`
        };
      } catch (err) {
        console.error('Balance check failed:', err);
        return { solSufficient: true, usdcSufficient: true, solCurrent: 'Unknown', usdcCurrent: 'Unknown' };
      }
    }

    async function payNow() {
      if (!currentInvoice) return;
      const chain = chainSelect.value;
      if (!wallet && chain === 'solana') {
        alert('Connect your wallet before attempting to pay.');
        return;
      }

      try {
        statusPanel.innerHTML = `<p class="text-yellow-400">‚è≥ Processing payment...</p>`;
        
        const method = methodSelect.value;
        const paramsInput = paramsInputElement.value.trim();
        
        let params = [];
        if (paramsInput) {
          try {
            params = JSON.parse(paramsInput);
          } catch (e) {
            params = [paramsInput];
          }
        }
        
        const facilitator = facilitatorSelect.value;
        const req = { method, params, chain, facilitator };

        const payment = await buildPayment(currentInvoice, chain);
        
        const retry = await fetch(API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x402-payment': JSON.stringify(payment),
          },
          body: JSON.stringify(req),
        });

        const data = await retry.json();
        
        if (data.x402) {
          const txHash = data.x402.paymentInfo.txHash;
          const explorerUrl = data.x402.paymentInfo.explorer;
          
          statusPanel.innerHTML = `
            <div class="bg-green-900 bg-opacity-30 border border-green-500 rounded-lg p-4">
              <p class="text-green-300 font-semibold mb-3"> Payment Successful!</p>
              <div class="space-y-2">
                <div>
                  <p class="text-green-200 text-xs mb-1">Transaction Hash:</p>
                  <p class="text-green-100 font-mono text-xs break-all bg-green-950 bg-opacity-50 p-2 rounded">${txHash}</p>
                </div>
                <a href="${explorerUrl}" target="_blank" class="inline-block mt-2 px-3 py-1 bg-green-600 hover:bg-green-700 text-white text-sm rounded">
                  View on Helius Explorer ‚Üí
                </a>
              </div>
            </div>
          `;
          
          const rpcResult = { ...data };
          delete rpcResult.x402;
          
          if (rpcResult.error) {
            document.getElementById('response').innerHTML = `
              <div class="text-orange-300 mb-2"> Payment succeeded, but RPC call failed:</div>
              <pre class="text-orange-200 text-xs">${JSON.stringify(rpcResult, null, 2)}</pre>
            `;
          } else {
            if (method === 'sendTransaction' && rpcResult.result) {
              document.getElementById('response').innerHTML = `
                <div class="text-blue-300 mb-2"> Transaction Broadcast Successful!</div>
                <div class="bg-gray-900 p-3 rounded mb-2">
                  <p class="text-xs text-gray-400 mb-1">Transaction Signature:</p>
                  <p class="text-green-400 font-mono text-xs break-all">${rpcResult.result}</p>
                </div>
                <a href="https://orb.helius.dev/tx/${rpcResult.result}" target="_blank" class="inline-block px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded">
                  View on Helius Explorer ‚Üí
                </a>
                <pre class="text-gray-400 text-xs mt-3">${JSON.stringify(rpcResult, null, 2)}</pre>
              `;
            } else {
              document.getElementById('response').textContent = JSON.stringify(rpcResult, null, 2);
            }
          }
        } else if (data.error) {
          statusPanel.innerHTML = `
            <div class="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4">
              <p class="text-red-300 font-semibold mb-2">Payment Failed</p>
              <p class="text-red-200 text-xs mb-1">${data.error}</p>
              ${data.facilitator ? `<p class="text-red-200 text-xs">Facilitator: ${data.facilitator}</p>` : ''}
            </div>
          `;
          document.getElementById('response').textContent = JSON.stringify(data, null, 2);
      } else {
          statusPanel.innerHTML = `<p class="text-green-300">‚úÖ Payment processed.</p>`;
        document.getElementById('response').textContent = JSON.stringify(data, null, 2);
        }
      } catch (err) {
        console.error('Payment failed:', err);
        statusPanel.innerHTML = `
          <div class="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4">
            <p class="text-red-300 font-semibold"> Payment Failed</p>
            <p class="text-red-200 text-sm">${err.message}</p>
          </div>
        `;
      }
    }

    async function buildPayment(paymentDetails, chain) {
      try {
        console.log('üí∞ Building payment for chain:', chain);
        console.log('   Facilitator:', facilitatorSelect.value);
        console.log('   Payment details:', {
          maxAmountRequired: paymentDetails.maxAmountRequired,
          asset: paymentDetails.asset,
          network: paymentDetails.network,
          payTo: paymentDetails.payTo?.substring(0, 20) + '...'
        });
        
      if (chain === 'base') {
          const sig = await window.ethereum.request({
            method: 'personal_sign',
            params: [wallet.publicKey.toBase58(), JSON.stringify(paymentDetails)]
          });
        return {
            paymentPayload: { signedIntent: { signature: sig } },
          paymentRequirements: { 
            amount: parseFloat(paymentDetails.maxAmountRequired), 
            recipient: paymentDetails.payTo 
          },
        };
      }

        const facilitator = facilitatorSelect.value;
        const { Transaction, PublicKey, SystemProgram } = window.solanaWeb3;

        // === CODENUT PAY (USDC on Solana/Base) ===
        // Use same simple pattern as x402labs but with USDC instead of SOL
        if (facilitator === 'codenut') {
          console.log('ü•ú Using CodeNut facilitator (USDC)');
          console.log('   Building USDC transfer transaction...');
          
          const recipient = new PublicKey(paymentDetails.payTo);
          const amountBaseUnits = parseInt(paymentDetails.maxAmountRequired, 10);
          
          console.log('   Amount (micro-USDC):', amountBaseUnits);
          console.log('   Recipient:', recipient.toBase58());
          
          const usdcMint = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
          const sourceATA = await window.splToken.getAssociatedTokenAddress(usdcMint, wallet.publicKey);
          
          console.log('   Source ATA:', sourceATA.toBase58());
          
          const feePayerStr = paymentDetails.extra?.feePayer || 'HsozMJWWHNADoZRmhDGKzua6XW6NNfNDdQ4CkE9i5wHt';
          const feePayer = new PublicKey(feePayerStr);
          console.log('   Facilitator fee payer:', feePayer.toBase58());
          
          const transactionPayer = wallet.publicKey;
          
          let destinationAccount = recipient;
          let requiresATAInit = false;
          let destinationDescription = 'direct account';
          
          try {
            const payToInfoRes = await fetch(SOLANA_RPC_PROXY, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                method: 'getAccountInfo',
                params: [recipient.toBase58(), { encoding: 'jsonParsed' }]
              })
            });
            const payToInfo = await payToInfoRes.json();
            const accountOwner = payToInfo.result?.value?.owner;
            const isTokenAccount = accountOwner === window.splToken.TOKEN_PROGRAM_ID.toBase58();
            
            if (isTokenAccount) {
              destinationAccount = recipient;
              destinationDescription = 'merchant USDC token account (provided in invoice)';
              console.log('   payTo is already a USDC token account ‚Äì no ATA derivation needed');
            } else {
              destinationAccount = await window.splToken.getAssociatedTokenAddress(usdcMint, recipient);
              destinationDescription = 'derived merchant USDC ATA';
              console.log('   Derived merchant ATA from wallet address');
              
              try {
                const ataCheckRes = await fetch(SOLANA_RPC_PROXY, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getAccountInfo',
                    params: [destinationAccount.toBase58(), { encoding: 'base64' }]
                  })
                });
                const ataCheckData = await ataCheckRes.json();
                requiresATAInit = !ataCheckData.result?.value;
              } catch (err) {
                console.warn('   ‚ö†Ô∏è  Unable to confirm facilitator ATA existence, will attempt to create lazily', err);
                requiresATAInit = true;
              }
            }
          } catch (err) {
            console.warn('   ‚ö†Ô∏è  Could not inspect payTo account ‚Äì defaulting to derived ATA path', err);
            destinationAccount = await window.splToken.getAssociatedTokenAddress(usdcMint, recipient);
            destinationDescription = 'derived merchant USDC ATA (fallback)';
            requiresATAInit = true;
          }
          
          console.log('   Destination:', destinationAccount.toBase58());
          console.log('   Destination description:', destinationDescription);
          console.log('   Will create ATA:', requiresATAInit);
          
          const tx = new Transaction();
          
          // CodeNut requires compute budget instructions first
          tx.add(window.splToken.createComputeUnitLimitInstruction(200000));
          tx.add(window.splToken.createComputeUnitPriceInstruction(1));
          
          if (requiresATAInit) {
            console.log('   Creating facilitator USDC ATA inline...');
            tx.add(
              window.splToken.createAssociatedTokenAccountInstruction(
                feePayer,
                destinationAccount,
                recipient,
                usdcMint
              )
            );
          }
          
          tx.add(
            window.splToken.createTransferCheckedInstruction(
              sourceATA,
              usdcMint,
              destinationAccount,
              wallet.publicKey,
              amountBaseUnits,
              6
            )
          );
          
          const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getLatestBlockhash',
              params: [{ commitment: 'finalized' }]
            })
          });
          const blockhashData = await blockhashRes.json();
          tx.recentBlockhash = blockhashData.result.value.blockhash;
          tx.feePayer = feePayer;
          
          console.log('   Transaction ready, requesting signature...');
          
          let signed;
          try {
            signed = await wallet.signTransaction(tx);
          } catch (err) {
            console.error('   ‚ùå Phantom failed to sign transaction', err);
            throw err;
          }
          const serialized = signed.serialize({ requireAllSignatures: false });
          
          const binaryChunks = [];
          const chunkSize = 8192;
          for (let i = 0; i < serialized.length; i += chunkSize) {
            const chunk = Array.from(serialized.slice(i, i + chunkSize));
            binaryChunks.push(String.fromCharCode.apply(null, chunk));
          }
          const txBase64 = btoa(binaryChunks.join(''));
          console.log('‚úÖ Transaction signed and encoded (base64), size:', txBase64.length);
          
          const codeNutAsset = paymentDetails.asset && paymentDetails.asset !== 'USDC'
            ? paymentDetails.asset
            : usdcMint.toBase58();
          
          return {
            paymentPayload: {
              x402Version: 1,
              scheme: 'exact',
              network: 'solana',
              payload: {
                transaction: txBase64,
              },
            },
            paymentRequirements: {
              scheme: 'exact',
              network: 'solana',
              maxAmountRequired: String(amountBaseUnits),
              asset: codeNutAsset,
              payTo: paymentDetails.payTo,
              extra: {
                ...paymentDetails.extra,
                feePayer: feePayerStr,
              },
            },
          };
        }

        // === PayAI NETWORK (USDC on Solana) ===
        // PayAI x402-solana SDK requires client to build USDC transfer transaction
        if (facilitator === 'payai') {
          console.log('üí≥ Using PayAI Network facilitator (USDC)');
          console.log('   Building USDC transfer transaction...');
          
          // Import PublicKey from solanaWeb3 FIRST
          const { Transaction, PublicKey } = window.solanaWeb3;
          
          const microUSDC = Math.floor(parseFloat(paymentDetails.maxAmountRequired));
          console.log(`   Amount: ${microUSDC} micro-USDC (${microUSDC / 1e6} USDC)`);
          console.log('   To:', paymentDetails.payTo);
          
          // USDC mainnet mint
          const USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
          
          // Get associated token accounts (using window.splToken global)
          const fromATA = await window.splToken.getAssociatedTokenAddress(
            USDC_MINT,
            wallet.publicKey
          );
          
          const toATA = await window.splToken.getAssociatedTokenAddress(
            USDC_MINT,
            new PublicKey(paymentDetails.payTo)
          );
          
          console.log('   From USDC Account:', fromATA.toBase58());
          console.log('   To USDC Account:', toATA.toBase58());
          
          // Check if recipient's USDC account exists using our backend proxy
          console.log('   Checking if treasury USDC account exists...');
          let needsAccountCreation = false;
          
          try {
            const checkResponse = await fetch(SOLANA_RPC_PROXY, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                method: 'getAccountInfo',
                params: [
                  toATA.toBase58(),
                  { encoding: 'base64' }
                ]
              })
            });
            const { result } = await checkResponse.json();
            
            if (!result || !result.value) {
              console.log('   ‚ö†Ô∏è  Treasury USDC account does not exist - will create it');
              needsAccountCreation = true;
            } else {
              console.log('   ‚úÖ Treasury USDC account exists');
            }
          } catch (err) {
            console.log('   ‚ö†Ô∏è  Could not check account, will attempt to create');
            needsAccountCreation = true;
          }
          
          // Build USDC transfer transaction
          // CRITICAL: PayAI requires ComputeBudget instructions at positions 0 and 1
          // Reference: https://github.com/PayAINetwork/x402-solana/blob/main/src/client/transaction-builder.ts
          
          const tx = new Transaction();
          
          // Instruction 0: Set compute unit limit (PayAI requires up to 7,000 units for token transfers)
          tx.add(
            window.splToken.createComputeUnitLimitInstruction(7000)
          );
          
          // Instruction 1: Set compute unit price (< 5 lamports as per PayAI spec)
          tx.add(
            window.splToken.createComputeUnitPriceInstruction(1000000)  // 1 lamport = 1,000,000 microlamports
          );
          
          console.log('   ‚úÖ Added ComputeBudget instructions (required by PayAI)');
          
          // Instruction 2: CreateATA if needed (merchant's ATA must exist)
          // PayAI requires this instruction in the transaction
          let instructionIndex = 2;
          if (needsAccountCreation) {
            console.log('   üìù Creating treasury USDC account (ATA)...');
            
            // Create PublicKey from treasury address
            const treasuryPubkey = new PublicKey(paymentDetails.payTo);
            
            // Instruction: Create Associated Token Account for merchant
            // CRITICAL: Use TOKEN_PROGRAM_ID (Solana standard tokens, not Token-2022)
            tx.add(
              window.splToken.createAssociatedTokenAccountInstruction(
                wallet.publicKey,  // payer (user pays for account creation)
                toATA,             // associatedToken (the ATA we're creating)
                treasuryPubkey,    // owner (the merchant/treasury)
                USDC_MINT          // mint (USDC)
              )
            );
            
            console.log('   ‚úÖ Added CreateATA instruction for:', toATA.toBase58());
            instructionIndex = 3;
          }
          
          // Instruction 2 or 3: USDC TransferChecked (depending on whether we created ATA)
          tx.add(
            window.splToken.createTransferCheckedInstruction(
              fromATA,           // source
              USDC_MINT,         // mint
              toATA,             // destination  
              wallet.publicKey,  // owner (user signs this)
              microUSDC,         // amount in micro-USDC
              6                  // USDC decimals
            )
          );
          
          // Get fresh blockhash
          const response = await fetch(SOLANA_RPC_PROXY, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getLatestBlockhash',
              params: []
            })
          });
          const { result } = await response.json();
          
          tx.recentBlockhash = result.value.blockhash;
          
          // Extract facilitator feePayer
          const facilitatorFeePayer = paymentDetails.extra?.feePayer;
          if (!facilitatorFeePayer) {
            throw new Error(
              'Missing feePayer in paymentDetails.extra. ' +
              'PayAI Network requires facilitator feePayer address to be provided in the 402 invoice.'
            );
          }
          
          // Set facilitator as fee payer (required by PayAI)
          tx.feePayer = new PublicKey(facilitatorFeePayer);
          
          console.log('   Fee payer (PayAI facilitator):', facilitatorFeePayer);
          console.log('   User wallet:', wallet.publicKey.toBase58());
          console.log('   Transaction info before signing:');
          console.log('     - Instructions:', tx.instructions.length);
          console.log('     - Fee payer:', tx.feePayer.toBase58());
          console.log('     - Blockhash:', tx.recentBlockhash.substring(0, 8) + '...');
          console.log('   Requesting signature from Phantom...');
          
          // Sign with user's wallet (partial signature)
          const signed = await wallet.signTransaction(tx);
          console.log('‚úÖ Transaction signed by user');
          
          // Verify signature was actually added
          if (!signed.signatures || signed.signatures.length === 0) {
            throw new Error('Transaction signing failed: no signatures in transaction');
          }
          
          // Find user's signature
          const userSig = signed.signatures.find(sig => 
            sig.publicKey && sig.publicKey.equals(wallet.publicKey)
          );
          
          if (!userSig || !userSig.signature) {
            throw new Error('User signature missing from transaction');
          }
          
          console.log('‚úÖ User signature verified:', {
            publicKey: userSig.publicKey.toBase58(),
            signatureLength: userSig.signature.length,
            signaturePreview: bs58.encode(userSig.signature).substring(0, 20) + '...'
          });
          
          // Serialize partially signed transaction
          // Allow missing facilitator signature; PayAI will add it during settlement
          let serialized;
          try {
            serialized = signed.serialize({
              requireAllSignatures: false,
              verifySignatures: false,
            });
            if (!serialized || serialized.length === 0) {
              throw new Error('Transaction serialization returned empty or null');
            }
            console.log('‚úÖ Transaction serialized successfully, size:', serialized.length, 'bytes');
          } catch (serErr) {
            console.error('‚ùå Serialization error:', serErr);
            throw new Error('Failed to serialize transaction: ' + serErr.message);
          }
          
          // CRITICAL: Encode as BASE64 (not base58!) per PayAI reference
          // Reference: https://github.com/optimisticoracle/optimistic-oracle
          const txBase64 = btoa(String.fromCharCode.apply(null, serialized));
          console.log('‚úÖ Transaction encoded to base64, length:', txBase64.length);
          
          const nonce = paymentDetails.extra?.nonce || `${Date.now()}-${Math.random()}`;
          
          // Return in PayAI format (matches reference implementation exactly)
          // Reference: https://github.com/optimisticoracle/optimistic-oracle
          return {
            paymentPayload: {
              x402Version: 1,
              scheme: 'exact',
              network: 'solana',
              payload: {
                transaction: txBase64  // base64 encoded
              }
            },
            paymentRequirements: {
              scheme: 'exact',
              network: 'solana',
              maxAmountRequired: String(microUSDC),
              asset: {
                address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
              },
              payTo: paymentDetails.payTo,
              resource: paymentDetails.resource || '',
              description: 'x402 RPC payment',
              extra: {
                feePayer: facilitatorFeePayer
              }
            }
          };
        }
        
        // === x402labs (SOL) ===
        if (facilitator === 'x402labs') {
          console.log('üèóÔ∏è Building SOL transfer transaction for x402labs...');
          
          // Get latest blockhash with retry for Triton
          const isTriton = paymentDetails.extra?.provider?.toLowerCase().includes('triton');
          const getLatestBlockhashWithRetry = async () => {
            for (let attempt = 1; attempt <= (isTriton ? 3 : 1); attempt++) {
              try {
                const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ method: 'getLatestBlockhash', params: [] })
                });
                const blockhashData = await blockhashRes.json();
                if (blockhashData.result?.value?.blockhash) return blockhashData.result.value.blockhash;
              } catch (e) {
                if (attempt === (isTriton ? 3 : 1)) throw new Error('Failed to get blockhash');
                await new Promise(resolve => setTimeout(resolve, 500));
              }
            }
          };

          // Get blockhash via proxy (CORS-enabled)
          console.log('üì° Getting recent blockhash via proxy...');
          const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              jsonrpc: '2.0',
              id: 1,
              method: 'getLatestBlockhash',
              params: [{ commitment: 'finalized' }]  // Use finalized for maximum compatibility
            })
          });
          const blockhashData = await blockhashRes.json();
          const blockhash = blockhashData.result.value.blockhash;
          console.log(' Got blockhash:', blockhash.substring(0, 8) + '...');
          
          // Use the EXACT payment amount from invoice (more accurate, less suspicious to Phantom)
          const lamports = parseInt(paymentDetails.maxAmountRequired, 10);
          console.log('üí∞ Transfer amount:', lamports, `lamports (${(lamports / 1e9).toFixed(9)} SOL)`);
          
          // Create legacy transaction (most compatible with all Phantom versions)
          const { Transaction: LegacyTransaction } = window.solanaWeb3;
          const tx = new LegacyTransaction();
      tx.recentBlockhash = blockhash;
          tx.feePayer = wallet.publicKey;
          
          // v1.20.3 has working SystemProgram.transfer (no Blob.encode bug!)
          console.log(' Using native SystemProgram.transfer (v1.20.3 works!)');
          tx.add(
            SystemProgram.transfer({
              fromPubkey: wallet.publicKey,
              toPubkey: new PublicKey(paymentDetails.payTo),
              lamports: lamports
            })
          );
          console.log(' Added transfer instruction');
          console.log(' Transaction ready:', { 
            feePayer: tx.feePayer.toBase58().substring(0, 8) + '...',
            blockhash: tx.recentBlockhash.substring(0, 8) + '...',
            instructions: tx.instructions.length 
          });

          // Try to get Phantom's approval with detailed logging
          console.log(' Requesting signature from Phantom...');
          console.log(' Transaction details for Phantom:');
          console.log('   - From:', wallet.publicKey.toBase58());
          console.log('   - To:', paymentDetails.payTo);
          console.log('   - Amount:', lamports, 'lamports (0.01 SOL)');
          console.log('   - Recent blockhash:', tx.recentBlockhash);
          
          let signed;
          try {
            // Request signature from Phantom
            // Important: User must APPROVE in Phantom popup!
            signed = await wallet.signTransaction(tx);
            console.log('‚úÖ Transaction signed successfully!');
          } catch (signError) {
            console.error('‚ùå Phantom signing failed:', signError);
            console.error('   Error code:', signError.code);
            console.error('   Error message:', signError.message);
            
            // Check if user simply cancelled
            if (signError.code === 4001 || signError.message?.includes('User rejected')) {
              document.getElementById('status').innerHTML = `
                <div class="bg-yellow-900 bg-opacity-30 border border-yellow-500 rounded-lg p-4">
                  <p class="text-yellow-300 font-semibold mb-2">‚ö†Ô∏è Transaction Cancelled</p>
                  <p class="text-yellow-200 text-sm">You rejected the transaction in Phantom.</p>
                  <p class="text-yellow-200 text-sm mt-2">Click "Pay with Phantom" again to retry.</p>
                </div>
              `;
              throw new Error('User cancelled transaction');
            }
            
            // Other errors (unexpected)
            document.getElementById('status').innerHTML = `
              <div class="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4">
                <p class="text-red-300 font-semibold mb-2">‚ùå Phantom Error</p>
                <p class="text-red-200 text-sm mb-2">${signError.message || 'Unexpected error'}</p>
                <div class="mt-3 text-orange-200 text-xs">
                  <p class="font-semibold mb-1">üí° Quick Fixes:</p>
                  <ol class="list-decimal ml-4 space-y-1">
                    <li><strong>Unlock Phantom</strong> if it's locked</li>
                    <li><strong>Approve the transaction</strong> in Phantom popup (check for notification)</li>
                    <li><strong>Refresh page</strong> and reconnect wallet</li>
                    <li><strong>Check Phantom version</strong> - update if outdated</li>
                  </ol>
                  <p class="mt-2 font-semibold">üîç Error Code: ${signError.code || 'None'}</p>
                </div>
              </div>
            `;
            
            throw new Error(`Phantom signing failed: ${signError.message || 'Unexpected error'}`);
          }
          
          const serialized = signed.serialize();
          const txBase64 = bs58.encode(serialized);
          console.log('‚úÖ Transaction serialized, size:', serialized.length, 'bytes');

          // Extract transaction signature (first signature in the transaction)
          // This proves the wallet signed the transaction
          const txSignature = bs58.encode(signed.signatures[0].signature);
          console.log('‚úÖ Transaction signature:', txSignature.substring(0, 20) + '...');
          
          // Use transaction signature as payment intent proof
          // This is simpler and more reliable than asking Phantom to sign another message
          const nonce = paymentDetails.extra?.nonce || `${Date.now()}-${Math.random()}`;

          return {
            paymentPayload: {
              signedIntent: { 
                publicKey: wallet.publicKey.toBase58(), 
                signature: txSignature  // Use transaction signature as proof
              },
              txBase64,
              network: paymentDetails.network,
              paymentType: 'SOL'
            },
            paymentRequirements: { 
              amount: parseFloat(paymentDetails.maxAmountRequired), 
              recipient: paymentDetails.payTo, 
              nonce,
              resource: paymentDetails.resource || '/rpc'
            },
          };
        }
      } catch (error) {
        console.error('‚ùå Build payment failed:', error);
        console.error('   Error name:', error.name);
        console.error('   Error message:', error.message);
        console.error('   Error stack:', error.stack?.split('\n').slice(0, 3).join('\n'));
        
        // Re-throw with more context
        throw new Error(`Payment build failed: ${error.message || error}`);
      }
    }

    // Note: PayAI Network backend handles all USDC transfers via the PayAI SDK
    // Frontend only needs to sign payment intent messages
  </script>

  <!-- Real-Time Pricing Widget -->
  <script src="/shared-pricing-widget.js"></script>
</body>
</html>
