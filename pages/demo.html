<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Live Demo | x402 Labs - Micropayments for the Machine Economy</title>
  <link rel="icon" type="image/png" href="/assets/FullLogo_Transparent.png">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  
  <!-- Enhanced Buffer polyfill for Solana web3.js -->
  <script>
    (function() {
      // Complete Buffer polyfill that @solana/web3.js needs
      class BufferPolyfill extends Uint8Array {
        constructor(arg, encodingOrOffset, length) {
          if (typeof arg === 'number') {
            super(arg);
          } else if (typeof arg === 'string') {
            const encoded = new TextEncoder().encode(arg);
            super(encoded);
          } else {
            super(arg, encodingOrOffset, length);
          }
        }
        
        static from(value, encoding) {
          if (typeof value === 'string') {
            return new TextEncoder().encode(value);
          }
          if (value instanceof Uint8Array) {
            return value;
          }
          if (Array.isArray(value)) {
            return new Uint8Array(value);
          }
          if (value?.buffer) {
            return new Uint8Array(value.buffer);
          }
          return new Uint8Array(value);
        }
        
        static alloc(size, fill = 0) {
          const buf = new Uint8Array(size);
          if (fill !== 0) buf.fill(fill);
          return buf;
        }
        
        static allocUnsafe(size) {
          return new Uint8Array(size);
        }
        
        static isBuffer(obj) {
          return obj instanceof Uint8Array;
        }
        
        static concat(list, totalLength) {
          if (!totalLength) {
            totalLength = list.reduce((acc, buf) => acc + buf.length, 0);
          }
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const buf of list) {
            result.set(buf, offset);
            offset += buf.length;
          }
          return result;
        }
      }
      
      window.Buffer = BufferPolyfill;
      console.log('✅ Enhanced Buffer polyfill loaded');
      console.log('✅ Buffer.from:', typeof Buffer.from === 'function');
      console.log('✅ Buffer.alloc:', typeof Buffer.alloc === 'function');
    })();
  </script>

  <!-- Use v1.20.3 - Ancient stable version, proven to work with Phantom -->
  <script src="https://unpkg.com/@solana/web3.js@1.20.3/lib/index.iife.min.js"></script>
  
  <!-- Inline bs58 implementation (guaranteed to work) -->
  <script>
    // Minimal bs58 encode/decode for browser (no dependencies)
    const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    window.bs58 = {
      encode: function(buffer) {
        if (buffer.length === 0) return '';
        const digits = [0];
        for (let i = 0; i < buffer.length; i++) {
          let carry = buffer[i];
          for (let j = 0; j < digits.length; j++) {
            carry += digits[j] << 8;
            digits[j] = carry % 58;
            carry = (carry / 58) | 0;
          }
          while (carry > 0) {
            digits.push(carry % 58);
            carry = (carry / 58) | 0;
          }
        }
        let result = '';
        for (let i = 0; i < buffer.length && buffer[i] === 0; i++) result += '1';
        for (let i = digits.length - 1; i >= 0; i--) result += BASE58_ALPHABET[digits[i]];
        return result;
      },
      decode: function(string) {
        if (string.length === 0) return new Uint8Array(0);
        const bytes = [0];
        for (let i = 0; i < string.length; i++) {
          const value = BASE58_ALPHABET.indexOf(string[i]);
          if (value === -1) throw new Error('Invalid base58 character');
          let carry = value;
          for (let j = 0; j < bytes.length; j++) {
            carry += bytes[j] * 58;
            bytes[j] = carry & 0xff;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 0xff);
            carry >>= 8;
          }
        }
        for (let i = 0; i < string.length && string[i] === '1'; i++) bytes.push(0);
        return new Uint8Array(bytes.reverse());
      }
    };
    console.log('✅ Solana web3.js loaded:', typeof window.solanaWeb3 !== 'undefined');
    console.log('✅ bs58 loaded:', typeof window.bs58 !== 'undefined');
  </script>
  <!-- Add runtime SPL loader with check -->
  <script>
    let splLoaded = false;
    const loadSPL = async () => {
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          const script = document.createElement('script');
          script.src = 'https://raw.githubusercontent.com/solana-labs/solana-program-library/master/token/js/dist/index.iife.min.js';
          script.onload = () => {
            splLoaded = true;
            console.log('✅ SPL loaded on attempt ' + attempt);
            const payaiOption = document.querySelector('#facilitator option[value="payai"]');
            if (payaiOption) {
              payaiOption.disabled = false;
              payaiOption.text = 'PayAI (USDC)';
            }
          };
          script.onerror = () => { if (attempt === 3) console.error('❌ SPL failed after 3 attempts'); };
          document.head.appendChild(script);
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for load
          if (splLoaded) break;
        } catch (e) {
          console.error('SPL retry ' + attempt + ' failed:', e);
        }
      }
    };
    loadSPL();
  </script>
  
  <!-- x402 Labs theme (design.svg palette) -->
  <style>
    :root {
      --bg: #DFEFFB;
      --bg2: #E8F4F8;
      --text: #0E4D81;
      --primary: #177CCF;
      --primaryDark: #0E4D81;
      --card: #FFFFFF;
      --soft: #E7F1F9;
      --muted: #6B8CA8;
    }
    body { background: linear-gradient(135deg, var(--bg) 0%, var(--bg2) 100%) !important; color: var(--text) !important; }
    /* Map dark utility classes to light theme locally */
    .bg-gray-900 { background-color: var(--bg) !important; }
    .bg-gray-800 { background-color: var(--card) !important; border: 1px solid rgba(23,124,207,0.15); box-shadow: 0 6px 20px rgba(14,77,129,0.06); }
    .bg-gray-700 { background-color: var(--soft) !important; color: var(--text) !important; }
    .text-white { color: var(--text) !important; }
    .text-gray-400 { color: var(--muted) !important; }
    .text-blue-300 { color: var(--primary) !important; }
    .text-purple-400 { color: var(--primary) !important; }
    .bg-blue-600, .bg-purple-600, .bg-green-600 { background: linear-gradient(135deg, var(--primary) 0%, var(--primaryDark) 100%) !important; }
    .hover\:bg-blue-700:hover, .hover\:bg-purple-700:hover, .hover\:bg-green-700:hover { filter: brightness(0.95); }
    pre.bg-gray-900 { background-color: var(--soft) !important; color: var(--text) !important; }
    /* Inputs */
    input#wallet, input#params, select#method, select#facilitator { border: 1px solid rgba(23,124,207,0.15); }
    /* Back link */
    a[href="/"] { color: var(--primary) !important; }
    /* Status panels */
    .bg-orange-900 { background-color: rgba(23,124,207,0.08) !important; }
    .border-orange-500 { border-color: rgba(23,124,207,0.35) !important; }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">

  <div class="container mx-auto px-6 py-12">
    <div class="flex items-center justify-between mb-8">
    <a href="/" class="text-purple-400 hover:underline text-sm">&larr; Back to Home</a>
      <img src="/assets/FullLogo_Transparent.png" alt="x402 Labs" class="h-20 md:h-24">
    </div>
    <h1 class="text-4xl font-bold mb-2">Live Demo: Pay with x402</h1>
    <p class="text-gray-400 mb-8">Micropayments for the Machine Economy™</p>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- LEFT: Controls -->
      <div class="space-y-6">
        <div class="bg-gray-800 p-6 rounded-xl">
          <h2 class="text-xl font-semibold mb-4">1. Connect Wallet</h2>
          <button id="connect" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold">
            Connect Phantom
          </button>
          <p id="wallet" class="mt-2 text-sm text-gray-400"></p>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl">
          <h2 class="text-xl font-semibold mb-4">2. Make RPC Call</h2>
          <select id="facilitator" class="w-full p-2 bg-gray-700 rounded mb-3">
            <option value="payai" disabled>PayAI (USDC) - Loading...</option>
            <option value="xlab" selected>X-Labs solana network (SOL)</option>
          </select>
          <p class="text-xs text-gray-400 mb-2">💡 X-Labs uses SOL (no SPL-Token needed), PayAI uses USDC</p>
          <select id="method" class="w-full p-2 bg-gray-700 rounded mb-3">
            <option value="getSlot">getSlot (Solana) - no params needed</option>
            <option value="getBalance">getBalance (Solana) - needs address</option>
            <option value="sendTransaction">sendTransaction (Solana) - broadcast tx</option>
            <option value="eth_blockNumber">eth_blockNumber (Base)</option>
          </select>
          <input id="params" placeholder='Empty for getSlot, or paste address for getBalance' class="w-full p-2 bg-gray-700 rounded mb-3 text-sm" />
          <button id="buildTx" class="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm mb-2" style="display:none;">
            📦 Build Sample Transaction
          </button>
          <button id="call" class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-semibold">
            Call RPC
          </button>
        </div>

        <div id="status" class="bg-gray-800 p-4 rounded-xl text-sm"></div>
      </div>

      <!-- RIGHT: Response -->
      <div class="space-y-6">
        <div class="bg-gray-800 p-6 rounded-xl">
          <h2 class="text-xl font-semibold mb-4">Request</h2>
          <pre id="request" class="bg-gray-900 p-3 rounded text-xs overflow-auto h-32 text-green-400"></pre>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl">
          <h2 class="text-xl font-semibold mb-4">Response</h2>
          <pre id="response" class="bg-gray-900 p-3 rounded text-xs overflow-auto h-48 text-blue-300"></pre>
        </div>
      </div>
    </div>
  </div>

  <script>
    const BASE_URL = window.location.hostname === 'localhost' 
      ? 'http://localhost:3000'
      : window.location.origin;
    
    const API = `${BASE_URL}/rpc`;
    const SOLANA_RPC_PROXY = `${BASE_URL}/solana-rpc`;
    
    console.log('Using API:', API);
    console.log('Using Solana RPC Proxy:', SOLANA_RPC_PROXY);
    
    let wallet = null;
    let currentInvoice = null;
    let sampleTxBase58 = null;

    document.getElementById('connect').onclick = async () => {
      if (!window.solana?.isPhantom) {
        document.getElementById('wallet').innerHTML = `<span class="text-red-400">Phantom not found</span>`;
        return;
      }
      
      try {
        await window.solana.connect();
        wallet = window.solana;
        
        const balanceCheck = await checkBalance(wallet);
        
        document.getElementById('wallet').innerHTML = `
          <span class="text-green-400">✅ Connected</span><br>
          <span class="text-xs">${wallet.publicKey.toBase58().slice(0,8)}...</span><br>
          <span class="text-sm ${balanceCheck.solSufficient ? 'text-green-400' : 'text-orange-400'}">SOL: ${balanceCheck.solCurrent}</span><br>
          <span class="text-sm ${balanceCheck.usdcSufficient ? 'text-green-400' : 'text-orange-400'}">USDC: ${balanceCheck.usdcCurrent}</span>
          ${!balanceCheck.usdcSufficient ? '<br><span class="text-red-400 text-xs">⚠️ Low USDC</span>' : ''}
        `;
      } catch (err) {
        document.getElementById('wallet').innerHTML = `<span class="text-red-400">❌ ${err.message}</span>`;
      }
    };

    // Show/hide Build Transaction button based on method selection
    document.getElementById('method').addEventListener('change', (e) => {
      const buildBtn = document.getElementById('buildTx');
      const paramsInput = document.getElementById('params');
      
      if (e.target.value === 'sendTransaction') {
        buildBtn.style.display = 'block';
        paramsInput.placeholder = 'Click "Build Sample Transaction" first, or paste base58 tx';
      } else {
        buildBtn.style.display = 'none';
        paramsInput.placeholder = 'Empty for getSlot, or paste address for getBalance';
      }
    });

    // Build sample transaction for sendTransaction
    document.getElementById('buildTx').onclick = async () => {
      if (!wallet) return alert('Connect wallet first');
      
      try {
        document.getElementById('buildTx').innerHTML = '⏳ Building...';
        
        const { Transaction, SystemProgram, PublicKey } = window.solanaWeb3;
        
        // Get recent blockhash
        const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            jsonrpc: '2.0',
            id: 1,
            method: 'getLatestBlockhash',
            params: [{ commitment: 'finalized' }]
          })
        });
        const blockhashData = await blockhashRes.json();
        const blockhash = blockhashData.result.value.blockhash;
        
        // Build a memo transaction (safe, cheap, demonstrative)
        const tx = new Transaction();
        tx.recentBlockhash = blockhash;
        tx.feePayer = wallet.publicKey;
        
        // Add memo instruction
        const memoText = `x402 Demo - ${new Date().toISOString()}`;
        const memoData = new TextEncoder().encode(memoText);
        const MEMO_PROGRAM_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
        
        const { TransactionInstruction } = window.solanaWeb3;
        tx.add(new TransactionInstruction({
          keys: [{ pubkey: wallet.publicKey, isSigner: true, isWritable: false }],
          programId: MEMO_PROGRAM_ID,
          data: memoData
        }));
        
        // Sign transaction
        const signed = await wallet.signTransaction(tx);
        const serialized = signed.serialize();
        sampleTxBase58 = bs58.encode(serialized);
        
        // Auto-fill params field
        document.getElementById('params').value = sampleTxBase58;
        document.getElementById('buildTx').innerHTML = '✅ Transaction Built!';
        document.getElementById('buildTx').classList.remove('bg-blue-600', 'hover:bg-blue-700');
        document.getElementById('buildTx').classList.add('bg-green-600');
        
        console.log('✅ Built sample transaction:', sampleTxBase58.substring(0, 20) + '...');
      } catch (err) {
        console.error('❌ Build failed:', err);
        document.getElementById('buildTx').innerHTML = '❌ Build Failed - Retry';
        document.getElementById('buildTx').classList.remove('bg-blue-600');
        document.getElementById('buildTx').classList.add('bg-red-600');
      }
    };

    document.getElementById('call').onclick = async () => {
      if (!wallet) return alert('Connect wallet first');

      const method = document.getElementById('method').value;
      const paramsInput = document.getElementById('params').value.trim();
      
      // Smart params parsing: handle JSON array, raw string, or empty
      let params = [];
      if (paramsInput) {
        try {
          params = JSON.parse(paramsInput); // Try parsing as JSON first
          console.log('✅ Parsed params as JSON:', params);
        } catch (e) {
          // If not valid JSON, treat as a single address/string and wrap in array
          console.log('✅ Auto-wrapped address in array:', [paramsInput]);
          params = [paramsInput];
        }
      } else {
        console.log('✅ No params (empty array)');
      }
      
      const facilitator = document.getElementById('facilitator').value;
      const chain = method.includes('eth') ? 'base' : 'solana';

      const req = { method, params, chain, facilitator };
      document.getElementById('request').textContent = JSON.stringify(req, null, 2);
      document.getElementById('status').innerHTML = `<p class="text-yellow-400">⏳ Sending...</p>`;

      try {
      const res = await fetch(API, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req),
      });

      if (res.status === 402) {
        const { invoice } = await res.json();
          currentInvoice = invoice;
          document.getElementById('response').textContent = JSON.stringify({ invoice }, null, 2);
          document.getElementById('status').innerHTML = `
            <div class="bg-orange-900 bg-opacity-30 border border-orange-500 rounded-lg p-4">
              <p class="text-orange-300 font-semibold mb-2">💳 Payment Required</p>
              <p class="text-orange-200 text-sm mb-2">Amount: <strong>$${invoice.amount}</strong></p>
              <p class="text-orange-200 text-sm mb-2">Provider: ${invoice.provider || 'Best Available'}</p>
              <p class="text-orange-200 text-xs mb-3">Payment: ${document.getElementById('facilitator').value === 'xlab' ? 'SOL (X-Labs)' : 'USDC (PayAI)'}</p>
              <button onclick="payNow()" class="mt-3 w-full px-4 py-2 bg-white text-purple-900 font-bold rounded-lg hover:bg-purple-100">
                💰 Pay with Phantom
              </button>
            </div>
          `;
        } else {
          const data = await res.json();
          document.getElementById('response').textContent = JSON.stringify(data, null, 2);
          if (data.x402) {
            document.getElementById('status').innerHTML = `
              <div class="bg-green-900 bg-opacity-30 border border-green-500 rounded-lg p-4">
                <p class="text-green-300 font-semibold">✅ Paid!</p>
                <p class="text-green-200 text-sm">Tx: <a href="${data.x402.paymentInfo.explorer}" target="_blank" class="underline">${data.x402.paymentInfo.txHash.slice(0,8)}...</a></p>
              </div>
            `;
          }
        }
      } catch (err) {
        document.getElementById('status').innerHTML = `<p class="text-red-400">❌ ${err.message}</p>`;
      }
    };

    async function checkBalance(wallet) {
      try {
        // Import PublicKey from solanaWeb3
        const { PublicKey } = window.solanaWeb3;
        
        // Existing SOL balance
        const solRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ method: 'getBalance', params: [wallet.publicKey.toBase58()] })
        });
        const solData = await solRes.json();
        const solBalance = solData.result?.value || 0;
        const solBalanceSOL = solBalance / 1e9;
        const minSOL = 0.001;

        // USDC balance (get ATA and balance) - check if splToken is available
        if (!window.splToken || typeof window.splToken.getAssociatedTokenAddress !== 'function') {
          console.warn('⚠️ SPL-Token not loaded, skipping USDC check');
          return {
            solSufficient: solBalanceSOL >= minSOL,
            usdcSufficient: true, // Can't check, assume OK
            solCurrent: `${solBalanceSOL.toFixed(4)} SOL`,
            usdcCurrent: 'N/A (SPL not loaded)'
          };
        }
        
        const USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
        const usdcATA = await window.splToken.getAssociatedTokenAddress(USDC_MINT, wallet.publicKey);
        const usdcRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ method: 'getTokenAccountBalance', params: [usdcATA.toBase58()] })
        });
        const usdcData = await usdcRes.json();
        let usdcBalance = 0;
        if (usdcData.result?.value) {
          usdcBalance = usdcData.result.value.uiAmount || 0;
        } else {
          console.warn('USDC ATA not found - balance 0');
        }
        const minUSDC = 0.02; // Example min for payments

        return {
          solSufficient: solBalanceSOL >= minSOL,
          usdcSufficient: usdcBalance >= minUSDC,
          solCurrent: `${solBalanceSOL.toFixed(4)} SOL`,
          usdcCurrent: `${usdcBalance.toFixed(2)} USDC`
        };
      } catch (err) {
        console.error('Balance check failed:', err);
        return { solSufficient: true, usdcSufficient: true, solCurrent: 'Unknown', usdcCurrent: 'Unknown' };
      }
    }

    async function payNow() {
      if (!wallet || !currentInvoice) return;

      try {
        document.getElementById('status').innerHTML = `<p class="text-yellow-400">⏳ Processing payment...</p>`;
        
        const method = document.getElementById('method').value;
        const paramsInput = document.getElementById('params').value.trim();
        
        // Same smart parsing as Call RPC button
        let params = [];
        if (paramsInput) {
          try {
            params = JSON.parse(paramsInput);
          } catch (e) {
            params = [paramsInput]; // Auto-wrap raw strings
          }
        }
        
        const facilitator = document.getElementById('facilitator').value;
        const chain = method.includes('eth') ? 'base' : 'solana';
        const req = { method, params, chain, facilitator };

        const payment = await buildPayment(currentInvoice, chain);
        
        const retry = await fetch(API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x402-payment': JSON.stringify(payment),
          },
          body: JSON.stringify(req),
        });

        const data = await retry.json();
        
        if (data.x402) {
          const txHash = data.x402.paymentInfo.txHash;
          const explorerUrl = data.x402.paymentInfo.explorer;
          
          // Display payment success status
          document.getElementById('status').innerHTML = `
            <div class="bg-green-900 bg-opacity-30 border border-green-500 rounded-lg p-4">
              <p class="text-green-300 font-semibold mb-3">✅ Payment Successful!</p>
              <div class="space-y-2">
                <div>
                  <p class="text-green-200 text-xs mb-1">Transaction Hash:</p>
                  <p class="text-green-100 font-mono text-xs break-all bg-green-950 bg-opacity-50 p-2 rounded">${txHash}</p>
                </div>
                <a href="${explorerUrl}" target="_blank" class="inline-block mt-2 px-3 py-1 bg-green-600 hover:bg-green-700 text-white text-sm rounded">
                  View on Helius Explorer →
                </a>
              </div>
            </div>
          `;
          
          // Display RPC result separately (without x402 wrapper)
          const rpcResult = { ...data };
          delete rpcResult.x402; // Remove payment info from RPC response display
          
          // Check if RPC call had an error
          if (rpcResult.error) {
            document.getElementById('response').innerHTML = `
              <div class="text-orange-300 mb-2">⚠️ Payment succeeded, but RPC call failed:</div>
              <pre class="text-orange-200 text-xs">${JSON.stringify(rpcResult, null, 2)}</pre>
            `;
          } else {
            // Special formatting for sendTransaction results
            const method = document.getElementById('method').value;
            if (method === 'sendTransaction' && rpcResult.result) {
              document.getElementById('response').innerHTML = `
                <div class="text-blue-300 mb-2">✅ Transaction Broadcast Successful!</div>
                <div class="bg-gray-900 p-3 rounded mb-2">
                  <p class="text-xs text-gray-400 mb-1">Transaction Signature:</p>
                  <p class="text-green-400 font-mono text-xs break-all">${rpcResult.result}</p>
                </div>
                <a href="https://orb.helius.dev/tx/${rpcResult.result}" target="_blank" class="inline-block px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded">
                  View on Helius Explorer →
                </a>
                <pre class="text-gray-400 text-xs mt-3">${JSON.stringify(rpcResult, null, 2)}</pre>
              `;
            } else {
              document.getElementById('response').textContent = JSON.stringify(rpcResult, null, 2);
            }
          }
      } else {
          // No payment info, just show the response
        document.getElementById('response').textContent = JSON.stringify(data, null, 2);
        }
      } catch (err) {
        console.error('Payment failed:', err);
        document.getElementById('status').innerHTML = `
          <div class="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4">
            <p class="text-red-300 font-semibold">❌ Payment Failed</p>
            <p class="text-red-200 text-sm">${err.message}</p>
          </div>
        `;
      }
    }

    async function buildPayment(invoice, chain) {
      try {
        console.log('💰 Building for chain:', chain);
        
      if (chain === 'base') {
          const sig = await window.ethereum.request({
            method: 'personal_sign',
            params: [wallet.publicKey.toBase58(), JSON.stringify(invoice)]
          });
        return {
            paymentPayload: { signedIntent: { signature: sig } },
          paymentRequirements: { amount: invoice.amount, recipient: invoice.to },
        };
      }

        const facilitator = document.getElementById('facilitator').value;
        const { Transaction, PublicKey, SystemProgram } = window.solanaWeb3;

        if (facilitator === 'xlab') {
          console.log('📌 Building SOL transfer transaction for X-Labs...');
          
          // Get latest blockhash with retry for Triton
          const getLatestBlockhashWithRetry = async () => {
            for (let attempt = 1; attempt <= (invoice.provider === 'triton' ? 3 : 1); attempt++) {
              try {
                const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ method: 'getLatestBlockhash', params: [] })
                });
                const blockhashData = await blockhashRes.json();
                if (blockhashData.result?.value?.blockhash) return blockhashData.result.value.blockhash;
              } catch (e) {
                if (attempt === (invoice.provider === 'triton' ? 3 : 1)) throw new Error('Failed to get blockhash');
                await new Promise(resolve => setTimeout(resolve, 500));
              }
            }
          };

          // Get blockhash via proxy (CORS-enabled)
          console.log('📡 Getting recent blockhash via proxy...');
          const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              jsonrpc: '2.0',
              id: 1,
              method: 'getLatestBlockhash',
              params: [{ commitment: 'finalized' }]  // Use finalized for maximum compatibility
            })
          });
          const blockhashData = await blockhashRes.json();
          const blockhash = blockhashData.result.value.blockhash;
          console.log('✅ Got blockhash:', blockhash.substring(0, 8) + '...');
          
          // Build transaction with enough SOL to satisfy Phantom's validation
          const lamports = 10000000; // 0.01 SOL (definitely enough for rent + fees)
          console.log('💰 Transfer amount:', lamports, 'lamports (0.01 SOL)');
          
          // Create legacy transaction (most compatible with all Phantom versions)
          const { Transaction: LegacyTransaction } = window.solanaWeb3;
          const tx = new LegacyTransaction();
      tx.recentBlockhash = blockhash;
          tx.feePayer = wallet.publicKey;
          
          // v1.20.3 has working SystemProgram.transfer (no Blob.encode bug!)
          console.log('✅ Using native SystemProgram.transfer (v1.20.3 works!)');
          tx.add(
            SystemProgram.transfer({
              fromPubkey: wallet.publicKey,
              toPubkey: new PublicKey(invoice.to),
              lamports: lamports
            })
          );
          console.log('✅ Added transfer instruction');
          console.log('✅ Transaction ready:', { 
            feePayer: tx.feePayer.toBase58().substring(0, 8) + '...',
            blockhash: tx.recentBlockhash.substring(0, 8) + '...',
            instructions: tx.instructions.length 
          });

          // Try to get Phantom's approval with detailed logging
          console.log('✍️ Requesting signature from Phantom...');
          console.log('📋 Transaction details for Phantom:');
          console.log('   - From:', wallet.publicKey.toBase58());
          console.log('   - To:', invoice.to);
          console.log('   - Amount:', lamports, 'lamports (0.01 SOL)');
          console.log('   - Recent blockhash:', tx.recentBlockhash);
          
          let signed;
          try {
            // Request signature from Phantom
            signed = await wallet.signTransaction(tx);
            console.log('✅✅✅ Transaction signed successfully! ✅✅✅');
          } catch (signError) {
            console.error('❌ Phantom signing STILL failed:', signError);
            console.error('   Error code:', signError.code);
            console.error('   Error message:', signError.message);
            
            // Display error to user in UI
            document.getElementById('status').innerHTML = `
              <div class="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-4">
                <p class="text-red-300 font-semibold mb-2">❌ Phantom Signing Rejected</p>
                <p class="text-red-200 text-sm mb-2">Error: ${signError.message || 'Unexpected error'}</p>
                <p class="text-red-200 text-sm mb-2">Code: ${signError.code || 'N/A'}</p>
                <div class="mt-3 text-orange-200 text-xs">
                  <p class="font-semibold mb-1">⚠️ Troubleshooting Steps:</p>
                  <ol class="list-decimal ml-4 space-y-1">
                    <li>Check if your Phantom wallet is locked</li>
                    <li>Try disconnecting and reconnecting Phantom</li>
                    <li>Update Phantom to the latest version</li>
                    <li>Check for any Phantom notifications/prompts</li>
                    <li>Try refreshing the page completely</li>
                    <li>If issue persists, try a different browser</li>
                  </ol>
                </div>
              </div>
            `;
            
            throw new Error(`Phantom signing rejected: ${signError.message || 'Unknown error'}`);
          }
          
          const serialized = signed.serialize();
          const txBase64 = bs58.encode(serialized);
          console.log('✅ Transaction serialized, size:', serialized.length, 'bytes');

          const intentMsg = new TextEncoder().encode(JSON.stringify({ 
            amount: invoice.amount, 
            to: invoice.to, 
            nonce: invoice.nonce, 
            resource: invoice.resource || '/rpc' 
          }));
          const intentSig = await wallet.signMessage(intentMsg, 'utf8');

      return {
        paymentPayload: {
              signedIntent: { publicKey: wallet.publicKey.toBase58(), signature: bs58.encode(intentSig.signature) },
              txBase64,
              network: 'solana-mainnet',
              paymentType: 'SOL'
            },
            paymentRequirements: { amount: invoice.amount, recipient: invoice.to, nonce: invoice.nonce },
          };
        } else {
          if (splLoaded) {
            console.log('💳 Using USDC for PayAI');
            const splToken = window.splToken;
            const USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
            const amountBigInt = BigInt(Math.floor(invoice.amount * 1e6));
            let blockhashData;
            const isTriton = invoice.provider === 'triton';
            for (let attempt = 1; attempt <= (isTriton ? 3 : 1); attempt++) {
              try {
                const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ method: 'getLatestBlockhash', params: [] })
                });
                blockhashData = await blockhashRes.json();
                if (blockhashData.result?.value?.blockhash) break;
              } catch (e) {
                if (attempt === (isTriton ? 3 : 1)) throw new Error('Failed to get blockhash');
                await new Promise(resolve => setTimeout(resolve, 500));
              }
            }
            const tx = new Transaction();
            tx.recentBlockhash = blockhashData.result.value.blockhash;
            tx.feePayer = wallet.publicKey;
            const fromATA = await splToken.getAssociatedTokenAddress(USDC_MINT, wallet.publicKey);
            await getOrCreateATA(tx, wallet.publicKey, USDC_MINT, wallet.publicKey, fromATA);
            const toATA = await splToken.getAssociatedTokenAddress(USDC_MINT, new PublicKey(invoice.to));
            await getOrCreateATA(tx, new PublicKey(invoice.to), USDC_MINT, wallet.publicKey, toATA);
            tx.add(splToken.createTransferInstruction(fromATA, toATA, wallet.publicKey, amountBigInt));
            const signed = await wallet.signTransaction(tx);
            const serialized = signed.serialize();
            const txBase64 = bs58.encode(serialized);
            const intentMsg = new TextEncoder().encode(JSON.stringify({ amount: invoice.amount, to: invoice.to, nonce: invoice.nonce, resource: invoice.resource || '/rpc' }));
            const intentSig = await wallet.signMessage(intentMsg, 'utf8');
            return {
              paymentPayload: {
                signedIntent: { publicKey: wallet.publicKey.toBase58(), signature: bs58.encode(intentSig.signature) },
                txBase64,
                network: 'solana-mainnet'
              },
              paymentRequirements: { amount: invoice.amount, recipient: invoice.to, nonce: invoice.nonce },
            };
          } else {
            console.warn('⚠️ SPL not loaded - Using SOL for PayAI');
            let blockhashData;
            const isTriton = invoice.provider === 'triton';
            for (let attempt = 1; attempt <= (isTriton ? 3 : 1); attempt++) {
              try {
                const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ method: 'getLatestBlockhash', params: [] })
                });
                blockhashData = await blockhashRes.json();
                if (blockhashData.result?.value?.blockhash) break;
              } catch (e) {
                if (attempt === (isTriton ? 3 : 1)) throw new Error('Failed to get blockhash');
                await new Promise(resolve => setTimeout(resolve, 500));
              }
            }
            const tx = new Transaction();
            tx.recentBlockhash = blockhashData.result.value.blockhash;
            tx.feePayer = wallet.publicKey;
            
            // Build transfer instruction MANUALLY (same as self-hosted)
            const lamports = 1000;
            const transferInstructionData = new Uint8Array(12);
            transferInstructionData[0] = 2;
            transferInstructionData[1] = 0;
            transferInstructionData[2] = 0;
            transferInstructionData[3] = 0;
            const lamportsView = new DataView(transferInstructionData.buffer, 4, 8);
            lamportsView.setBigUint64(0, BigInt(lamports), true);
            
            const { TransactionInstruction } = window.solanaWeb3;
            const transferIx = new TransactionInstruction({
              keys: [
                { pubkey: wallet.publicKey, isSigner: true, isWritable: true },
                { pubkey: new PublicKey(invoice.to), isSigner: false, isWritable: true }
              ],
              programId: new PublicKey('11111111111111111111111111111111'),
              data: transferInstructionData
            });
            
            tx.add(transferIx);
            const signed = await wallet.signTransaction(tx);
            const serialized = signed.serialize();
            const txBase64 = bs58.encode(serialized);
            const intentMsg = new TextEncoder().encode(JSON.stringify({ 
              amount: invoice.amount, 
              to: invoice.to, 
              nonce: invoice.nonce, 
              resource: invoice.resource || '/rpc' 
            }));
            const intentSig = await wallet.signMessage(intentMsg, 'utf8');
            return {
              paymentPayload: {
                signedIntent: { publicKey: wallet.publicKey.toBase58(), signature: bs58.encode(intentSig.signature) },
          txBase64,
          network: 'solana-mainnet',
                paymentType: 'SOL'
              },
              paymentRequirements: { amount: invoice.amount, recipient: invoice.to, nonce: invoice.nonce },
            };
          }
        }
      } catch (error) {
        console.error('❌ Build failed:', error);
        throw error;
      }
    }

    async function getOrCreateATA(tx, owner, mint, payer, ataAddress) {
      try {
        const ataRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ method: 'getAccountInfo', params: [ataAddress.toBase58(), { encoding: 'jsonParsed' }] })
        });
        const ataData = await ataRes.json();
        if (!ataData.result.value) {
          tx.add(window.splToken.createAssociatedTokenAccountInstruction(payer, ataAddress, owner, mint));
        }
      } catch (e) {
        console.warn('ATA check failed, attempting creation:', e);
        tx.add(window.splToken.createAssociatedTokenAccountInstruction(payer, ataAddress, owner, mint));
      }
      return ataAddress;
    }
  </script>
</body>
</html>
