<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI Agent Demo | x402 Labs - Micropayments for the Machine Economy</title>
  <link rel="icon" type="image/png" href="/assets/xlabs-new.png">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  
  <!-- Enhanced Buffer polyfill for Solana web3.js -->
  <script>
    (function() {
      // Create a robust Buffer polyfill that returns real Uint8Arrays
      const BufferPolyfill = {
        from: function(value, encoding) {
          if (typeof value === 'string') {
            return new Uint8Array(new TextEncoder().encode(value));
          }
          if (value instanceof Uint8Array) {
            return new Uint8Array(value);
          }
          if (Array.isArray(value)) {
            return new Uint8Array(value);
          }
          if (value?.buffer instanceof ArrayBuffer) {
            return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
          }
          return new Uint8Array(value);
        },
        
        alloc: function(size, fill = 0) {
          const buf = new Uint8Array(size);
          if (fill !== 0) buf.fill(fill);
          return buf;
        },
        
        allocUnsafe: function(size) {
          return new Uint8Array(size);
        },
        
        isBuffer: function(obj) {
          return obj instanceof Uint8Array || obj instanceof ArrayBuffer;
        },
        
        concat: function(list, totalLength) {
          if (!totalLength) {
            totalLength = list.reduce((acc, buf) => acc + buf.length, 0);
          }
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const buf of list) {
            result.set(new Uint8Array(buf), offset);
            offset += buf.length;
          }
          return result;
        }
      };
      
      window.Buffer = BufferPolyfill;
      console.log('‚úÖ Enhanced Buffer polyfill loaded');
    })();
  </script>
  
  <!-- x402 Labs theme (design.svg palette) -->
  <style>
    :root {
      --bg: #DFEFFB;
      --bg2: #E8F4F8;
      --text: #0E4D81;
      --primary: #177CCF;
      --primaryDark: #0E4D81;
      --card: #FFFFFF;
      --soft: #E7F1F9;
      --muted: #6B8CA8;
    }
    body { background: linear-gradient(135deg, var(--bg) 0%, var(--bg2) 100%) !important; color: var(--text) !important; }
    .bg-gray-900 { background-color: var(--bg) !important; }
    .bg-gray-800 { background-color: var(--card) !important; border: 1px solid rgba(23,124,207,0.15); box-shadow: 0 6px 20px rgba(14,77,129,0.06); }
    .text-white { color: var(--text) !important; }
    .text-gray-400 { color: var(--muted) !important; }
    .text-gray-500 { color: var(--muted) !important; }
    .text-purple-400 { color: var(--primary) !important; }
    .bg-gradient-to-r { background: linear-gradient(135deg, var(--primary) 0%, var(--primaryDark) 100%) !important; }
    .bg-blue-400, .text-blue-400 { color: var(--primary) !important; }
    .text-green-400 { color: #1EA971 !important; }
  </style>
  
  <!-- Use v1.20.3 - Ancient stable version, proven to work with Phantom -->
  <script src="https://unpkg.com/@solana/web3.js@1.20.3/lib/index.iife.min.js"></script>
  
  <!-- Inline bs58 implementation -->
  <script>
    const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    window.bs58 = {
      encode: function(buffer) {
        try {
          // Ensure buffer is a proper Uint8Array or array-like
          if (!buffer || typeof buffer.length === 'undefined') {
            console.error('‚ùå bs58.encode: buffer is not array-like:', buffer);
            throw new Error('Buffer must be array-like');
          }
          
          // Convert to plain array to avoid any prototype issues
          const bytes = Array.from(buffer);
          
          // Validate all bytes are numbers 0-255
          for (let i = 0; i < bytes.length; i++) {
            if (typeof bytes[i] !== 'number' || bytes[i] < 0 || bytes[i] > 255 || !Number.isInteger(bytes[i])) {
              console.error(`‚ùå bs58.encode: Invalid byte at index ${i}:`, bytes[i], typeof bytes[i]);
              throw new Error(`Invalid byte at index ${i}: ${bytes[i]} (type: ${typeof bytes[i]})`);
            }
          }
          
          if (bytes.length === 0) return '';
          
          const digits = [0];
          for (let i = 0; i < bytes.length; i++) {
            let carry = bytes[i];
            for (let j = 0; j < digits.length; j++) {
              carry += digits[j] << 8;
              digits[j] = carry % 58;
              carry = (carry / 58) | 0;
            }
            while (carry > 0) {
              digits.push(carry % 58);
              carry = (carry / 58) | 0;
            }
          }
          
          let result = '';
          for (let i = 0; i < bytes.length && bytes[i] === 0; i++) result += '1';
          for (let i = digits.length - 1; i >= 0; i--) result += BASE58_ALPHABET[digits[i]];
          return result;
        } catch (err) {
          console.error('‚ùå bs58.encode error:', err);
          throw err;
        }
      },
      decode: function(string) {
        if (typeof string !== 'string') {
          throw new Error('Input must be a string');
        }
        if (string.length === 0) return new Uint8Array(0);
        
        const bytes = [0];
        for (let i = 0; i < string.length; i++) {
          const value = BASE58_ALPHABET.indexOf(string[i]);
          if (value === -1) {
            throw new Error(`Non-base58 character "${string[i]}" at position ${i}`);
          }
          let carry = value;
          for (let j = 0; j < bytes.length; j++) {
            carry += bytes[j] * 58;
            bytes[j] = carry & 0xff;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 0xff);
            carry >>= 8;
          }
        }
        for (let i = 0; i < string.length && string[i] === '1'; i++) bytes.push(0);
        return new Uint8Array(bytes.reverse());
      }
    };
    console.log('‚úÖ bs58 loaded with enhanced validation');
  </script>
  
  <!-- Header Navigation (consistent across all pages) -->
  <style>
    .main-header {
      background: rgba(30, 41, 59, 0.5);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      border-bottom: 1px solid rgba(139, 92, 246, 0.1);
    }
    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .main-nav {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }
    .main-nav a {
      color: #cbd5e1;
      text-decoration: none;
      font-weight: 500;
      font-size: 0.9rem;
    }
    .main-nav a:hover {
      color: #a78bfa;
    }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">

  <!-- Header -->
  <header class="main-header">
    <div class="header-content">
      <a href="/" style="display: flex; align-items: center;">
        <img src="/assets/xlabs-new.png" alt="x402 Labs" style="height: 50px; width: auto;">
      </a>
      <nav class="main-nav">
        <a href="/">Home</a>
        <a href="/api-docs">API Docs</a>
        <a href="/api-reference">API Reference</a>
        <a href="/providers-ui">Providers</a>
        <a href="/demo">Demo</a>
        <a href="https://x.com/x402labs" target="_blank" rel="noopener noreferrer" style="display: inline-flex; align-items: center;">
          <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
          </svg>
        </a>
        <a href="https://github.com/x402-labs" target="_blank" rel="noopener noreferrer">
          <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
            <path d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z"/>
          </svg>
        </a>
      </nav>
    </div>
  </header>

  <div class="container mx-auto px-6 py-12">
    <div class="flex items-center justify-between mb-8">
      <h1 class="text-4xl font-bold">AI Agent Demo</h1>
    </div>
    <p class="text-gray-400 mb-2">AI-Powered Autonomous Agent ‚Ä¢ Daydreams Framework ‚Ä¢ x402 Micropayments ‚Ä¢ Solana RPC</p>
    <p class="text-gray-500 text-sm mb-8">Intelligent agent that autonomously executes RPC calls with automatic x402 payments</p>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- LEFT: Controls -->
      <div class="space-y-6">
        <div class="bg-gray-800 p-6 rounded-xl">
          <button id="start" class="w-full px-6 py-3 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 rounded-lg font-bold text-lg">
            Start Daydreams Agent
          </button>
          <p class="mt-4 text-sm text-gray-400">AI agent will intelligently execute RPC calls based on task description. Payments handled automatically via x402 (SOL).</p>
          <textarea id="task" placeholder="Enter task (e.g., 'Get current Solana slot, check balance, and broadcast a test transaction')" class="w-full mt-4 p-3 bg-gray-700 rounded text-sm text-gray-300" rows="3">Run 10 RPC calls including getSlot, getBalance, and sendTransaction</textarea>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl">
          <h3 class="font-semibold mb-2">Agent Status</h3>
          <p id="status" class="text-yellow-400">Ready</p>
        </div>
      </div>

      <!-- RIGHT: Live Log -->
      <div class="bg-gray-800 p-6 rounded-xl h-96 overflow-y-auto font-mono text-xs">
        <pre id="log"></pre>
      </div>
    </div>

    <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
      <div class="bg-gray-800 p-4 rounded-xl">
        <p class="text-2xl font-bold text-green-400" id="calls">0</p>
        <p class="text-sm text-gray-400">RPC Calls</p>
      </div>
      <div class="bg-gray-800 p-4 rounded-xl">
        <p class="text-2xl font-bold text-blue-400" id="paid">$0.00</p>
        <p class="text-sm text-gray-400">Total Paid</p>
      </div>
      <div class="bg-gray-800 p-4 rounded-xl">
        <p class="text-2xl font-bold text-purple-400" id="txs">0</p>
        <p class="text-sm text-gray-400">Txs Confirmed</p>
      </div>
    </div>
  </div>

  <script>
    // Auto-detect API URL
    const BASE_URL = window.location.hostname === 'localhost' 
      ? 'http://localhost:3000'
      : window.location.origin;
    
    const API = `${BASE_URL}/rpc`;
    const SOLANA_RPC_PROXY = `${BASE_URL}/solana-rpc`;  // Secure proxy
    
    console.log('Using x402 RPC API:', API);
    console.log('Using Solana RPC proxy (secure):', SOLANA_RPC_PROXY);
    const log = (msg) => {
      const el = document.createElement('div');
      el.innerHTML = `<span class="timestamp">[${new Date().toISOString().slice(11,19)}]</span> ${msg}`;
      document.getElementById('log').appendChild(el);
      el.scrollIntoView();
    };

    let calls = 0, paid = 0, txs = 0;
    const updateStats = () => {
      document.getElementById('calls').innerText = calls;
      document.getElementById('paid').innerText = `$${paid.toFixed(6)}`;
      document.getElementById('txs').innerText = txs;
    };

    document.getElementById('start').onclick = async () => {
      document.getElementById('start').disabled = true;
      document.getElementById('status').innerText = 'Starting Daydreams Agent...';
      log('ü§ñ Daydreams AI Agent initialized');

      const taskInput = document.getElementById('task');
      const task = (taskInput && taskInput.value ? taskInput.value.trim() : '') || 'Run 10 RPC calls including getSlot, getBalance, and sendTransaction';

      try {
        log(`üìù Task: ${task}`);
        log('üöÄ Sending task to Daydreams agent...');

        const response = await fetch(`${BASE_URL}/agent/execute`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
            task: task,
            sessionId: `session-${Date.now()}`,
            }),
          });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || `HTTP ${response.status}`);
        }

        const result = await response.json();
        
        log('‚úÖ Agent execution completed');
        log(`üìä Session: ${result.sessionId}`);
        log(`üìû RPC Calls Made: ${result.requestCount || 0}`);
        log(`üí∞ Total Paid: $${(result.totalPaid || 0).toFixed(6)}`);
        
        // Update stats
        calls = result.requestCount || 0;
        paid = result.totalPaid || 0;
        txs = result.transactions?.length || 0;
            updateStats();
            
        // Display agent response
        if (result.response) {
          log(`\nüìã Agent Response:\n${result.response}`);
            }
            
        // Display execution log
        if (result.log && Array.isArray(result.log)) {
          log('\nüìú Execution Log:');
          result.log.forEach((entry, idx) => {
            if (entry.method) {
              const status = entry.error ? '‚ùå' : '‚úÖ';
              log(`${status} ${entry.method}(${entry.chain}): ${entry.error || JSON.stringify(entry.result).substring(0, 80)}`);
          }
          });
        }

        document.getElementById('status').innerHTML = '<span class="text-green-400">Complete</span>';
      } catch (err) {
        log(`‚ùå Error: ${err.message || err}`);
        document.getElementById('status').innerText = 'Error';
      } finally {
        document.getElementById('start').disabled = false;
      }
    };

    async function buildSampleTransaction(wallet) {
      try {
        const { Transaction, SystemProgram, PublicKey } = window.solanaWeb3;
        
        // Get recent blockhash
        const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            jsonrpc: '2.0',
            id: 1,
            method: 'getLatestBlockhash',
            params: [{ commitment: 'finalized' }]
          })
        });
        const blockhashData = await blockhashRes.json();
        const blockhash = blockhashData.result.value.blockhash;
        
        // Build a simple self-transfer (will fail but demonstrates sendTransaction)
        const tx = new Transaction();
        tx.recentBlockhash = blockhash;
        tx.feePayer = wallet.publicKey;
        
        // Add a memo instruction (safe, won't actually execute)
        const memoData = Buffer.from('x402 Agent Test Transaction', 'utf8');
        const MEMO_PROGRAM_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
        
        tx.add({
          keys: [{ pubkey: wallet.publicKey, isSigner: true, isWritable: false }],
          programId: MEMO_PROGRAM_ID,
          data: memoData
        });
        
        // Sign the transaction
        const signed = await wallet.signTransaction(tx);
        const serialized = signed.serialize();
        
        // Return base58-encoded transaction (Solana RPC format)
        return bs58.encode(serialized);
      } catch (err) {
        log(`‚ö†Ô∏è Failed to build sample tx: ${err.message}`);
        return null; // Return null, agent will skip this task
      }
    }

    async function payWithX402(paymentDetails, chain, wallet) {
      try {
        log('üí∞ Building payment for ' + chain + '...');
        
        if (chain === 'base') {
          const { signMessage } = window.ethereum;
          const msg = new TextEncoder().encode(JSON.stringify(paymentDetails));
          const sig = await signMessage(msg);
          return {
            paymentPayload: { signedIntent: { signature: bs58.encode(sig) } },
            paymentRequirements: { 
              amount: parseFloat(paymentDetails.maxAmountRequired), 
              recipient: paymentDetails.payTo 
            },
          };
        }

        // Solana - use 10M lamports (0.01 SOL) for reliable payments (same as demo.html)
        const { Transaction, SystemProgram, PublicKey } = window.solanaWeb3;
        
        // Get blockhash via proxy (finalized commitment for stability)
        log('üì° Getting blockhash...');
        const blockhashRes = await fetch(SOLANA_RPC_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            jsonrpc: '2.0',
            id: 1,
            method: 'getLatestBlockhash',
            params: [{ commitment: 'finalized' }]
          })
        });
        const blockhashData = await blockhashRes.json();
        
        if (!blockhashData.result?.value?.blockhash) {
          throw new Error('Failed to get blockhash');
        }
        
        const blockhash = blockhashData.result.value.blockhash;
        log('‚úÖ Got blockhash: ' + blockhash.substring(0,8) + '...');
        
        // Build transaction
        const tx = new Transaction();
        tx.recentBlockhash = blockhash;
        tx.feePayer = wallet.publicKey;

        // Use 10M lamports (0.01 SOL) to cover rent + fees
        const lamports = 10000000;
        tx.add(SystemProgram.transfer({
          fromPubkey: wallet.publicKey,
          toPubkey: new PublicKey(paymentDetails.payTo),
          lamports: lamports  // v1.20.3 handles this correctly
        }));

        log('‚úçÔ∏è Requesting transaction signature...');
        let signed;
        try {
          signed = await wallet.signTransaction(tx);
          log('‚úÖ Transaction signed');
        } catch (signErr) {
          throw new Error('Transaction signing failed: ' + signErr.message);
        }
        
        let serialized;
        try {
          serialized = signed.serialize();
          console.log('üîç Serialized type:', serialized.constructor.name);
          console.log('üîç Serialized instanceof Uint8Array:', serialized instanceof Uint8Array);
          console.log('üîç Serialized length:', serialized.length);
          
          // Ensure it's a proper Uint8Array (not a Buffer subclass or weird object)
          if (!(serialized instanceof Uint8Array)) {
            console.warn('‚ö†Ô∏è Serialized is not Uint8Array, converting...');
            serialized = new Uint8Array(serialized);
          }
        } catch (serErr) {
          throw new Error('Transaction serialization failed: ' + serErr.message);
        }
        
        let txBase64;
        try {
          // Verify each byte is a valid number before encoding
          for (let i = 0; i < Math.min(5, serialized.length); i++) {
            console.log(`üîç Byte ${i}:`, serialized[i], typeof serialized[i]);
          }
          
          txBase64 = bs58.encode(serialized);
          console.log('üîç txBase64 (first 16 chars):', txBase64.substring(0, 16));
          log('‚úÖ Transaction serialized (' + serialized.length + ' bytes)');
        } catch (encErr) {
          console.error('‚ùå Encoding error details:', encErr);
          console.error('‚ùå Serialized data:', serialized);
          throw new Error('Transaction encoding failed: ' + encErr.message);
        }

        // Sign intent message  
        const nonce = paymentDetails.extra?.nonce || `${Date.now()}-${Math.random()}`;
        const intentMessage = JSON.stringify({
          amount: parseFloat(paymentDetails.maxAmountRequired),
          to: paymentDetails.payTo,
          nonce: nonce,
          resource: paymentDetails.resource || '/rpc'
        });
        
        log('‚úçÔ∏è Signing payment intent...');
        const intentMsg = new TextEncoder().encode(intentMessage);
        
        let intentSig;
        try {
          intentSig = await wallet.signMessage(intentMsg, 'utf8');
          console.log('üîç Debug intentSig:', intentSig);
          console.log('üîç intentSig.signature type:', typeof intentSig.signature);
          console.log('üîç intentSig.signature instanceof Uint8Array:', intentSig.signature instanceof Uint8Array);
          console.log('üîç intentSig.signature length:', intentSig.signature?.length);
          log('‚úÖ Intent signed');
        } catch (intentErr) {
          throw new Error('Intent signing failed: ' + intentErr.message);
        }
        
        // Ensure intentSig.signature is a Uint8Array before encoding
        if (!intentSig || !intentSig.signature) {
          throw new Error('Invalid signature from wallet');
        }
        
        // Phantom returns signature as Uint8Array, encode it to base58
        let signatureBase58;
        try {
          signatureBase58 = bs58.encode(intentSig.signature);
          console.log('üîç signatureBase58:', signatureBase58.substring(0, 16) + '...');
          log('‚úÖ Payment ready to submit');
        } catch (sigEncErr) {
          throw new Error('Signature encoding failed: ' + sigEncErr.message);
        }

        return {
          paymentPayload: {
            signedIntent: { 
              publicKey: wallet.publicKey.toBase58(), 
              signature: signatureBase58
            },
            txBase64,
            network: paymentDetails.network,
            paymentType: 'SOL'  // Important: tell server this is SOL not USDC
          },
          paymentRequirements: { 
            amount: parseFloat(paymentDetails.maxAmountRequired), 
            recipient: paymentDetails.payTo,
            nonce: nonce
          },
        };
      } catch (error) {
        log('‚ùå Payment build failed: ' + error.message);
        throw error;
      }
    }
  </script>

  <style>
    .timestamp { color: #94a3b8; margin-right: 8px; }
  </style>
</body>
</html>